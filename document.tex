\documentclass[12pt,a4paper]{article}
\usepackage[left=2.00cm, right=2.00cm, top=2.00cm, bottom=2.00cm]{geometry}
\usepackage[tiny]{titlesec}
\usepackage[utf8x]{inputenc}
\usepackage[polish]{babel}
\usepackage[T1]{fontenc}
\usepackage{ucs}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{circuitikz}
\usepackage{subcaption}


\hypersetup{
	colorlinks   = true,    % Colours links instead of ugly boxes
	urlcolor     = blue,    % Colour for external hyperlinks
	linkcolor    = blue,    % Colour of internal links
	citecolor    = red      % Colour of citations
}

\title{Pytania i odpowiedzi na obronę pracy inżynierskiej}
\author{
	Zachodniopomorski Uniwersytet Technologiczny\\
	Wydział Informatyki\\
	Szczecin
}
\date{\today}

\begin{document}
	\maketitle

	\section{Co to jest algorytm - cechy i właściwości}
	Algorytm jest skończonym, uporządkowanym ciągiem jasno zdefiniowanych czynności, koniecznych do wykonania postawionego  zadania.
	Cechy algorytmów:
	\begin{itemize}
		\item \textbf{poprawność} - algorytm daje oczekiwane wyniki,
		\item \textbf{jednoznaczność} - zawsze daje te same wyniki przy takich samych danych wejściowych,
		\item \textbf{skończoność} - wykonuje się w skończonej liczbie kroków,
		\item \textbf{sprawność} - czasowa - szybkość działania i pamięciowa.
	\end{itemize}
	Właściwości algorytmów:
	\begin{itemize}
		\item \textbf{efektywność} - algorytm powinien osiągać efekt końcowy możliwie niskim kosztem,
		\item \textbf{zgodność ze specyfikacją},
		\item \textbf{właściwość stopu} - algorytm powinien zatrzymać się w skończonym czasie (po wykonaniu lub mimo niewykonania postawionego zadania).
	\end{itemize}

	\section{Porównać pojęcia program, algorytm, procedura, funkcja, agent programowy.}
	\begin{itemize}
		\item \textbf{Program} - zaimplementowany algorytm w sposób zrozumiały dla komputera/maszyny go wykonującej.
		\item\textbf{Procedura} - program w trakcie wykonania. Wykonuje operacje, ale nie zwraca wartości.
		\item \textbf{Funkcja} - część składowa programu zwracająca wartość
		\item \textbf{Agent programowy (zwany także systemem agentowym, agentem)} - system oparty na wiedzy. Definiuje się go jako autonomiczny program umieszczony w określonym otoczeniu (i będący jego częścią), który potrafi analizować to otoczenie i oddziaływać na nie w czasie, dążyć do wyznaczonych celów i symulować wpływ zmian tego otoczenia.
	\end{itemize}

	\section{Rodzaje zabezpieczeń systemów komputerowych}
	\begin{itemize}
		\item \textbf{fizyczne} - wszelkie zabezpieczenia przed otwarciem pokrywy komputera, zamki, blokady, zabezpieczenia antykradzieżowe, kontrola dostępu do obiektów i pomieszczeń, systemy przeciwpożarowe,
		\item \textbf{techniczne} - software, oprogramowanie antywirusowe, kontrola dostępu, szyfrowanie informacji
		\item \textbf{organizacyjne} - regulaminy dla osób korzystających z systemów informatycznych, polityka bezpieczeństwa,
		\item \textbf{personalne} - sprawdzanie pracowników dopuszczonych do danych o szczególnym znaczeniu, przestrzeganie odpowiednich procedur zwalniania i zatrudniania pracowników, szkolenia.
	\end{itemize}

	\section{Urządzenia wejścia i wyjścia}
	Urządzenia służące do wydobywania/przekazywania informacji z/do komputera, na przykład: mysz komputerowa, klawiatura, monitor, drukarka, skaner.

	\section{Scharakteryzować architekturę klient-serwer oraz klient-broker-serwer.}
	\begin{itemize}
		\item  \textbf{Klient-serwer} - program klienta (aktywny) wysyła żądania do serwera, który te zapytania przetwarza i dostarcza odpowiednią usługę. Z reguły serwer (pasywny) jest jeden i może obsługiwać wiele klientów.
		\item \textbf{Klient-broker-serwer} - pomiędzy klientem a serwerem jest pośrednik (broker), który jest odpowiedzialny za odbieranie wszystkich wiadomości, ich filtrowanie, określanie kto jest odbiorcą wiadomości oraz ich przesyłanie. Odpowiada również za przechowywanie danych o sesjach oraz autoryzację klientów.
	\end{itemize}

	\section{Wymienić i omówić metody wdrażania systemów informatycznych.}
	Odpowiedź niepewna (źr. \href{https://pl.wikipedia.org/wiki/Wdro\%C5\%BCenie_systemu}{Wikipedia}).

	\begin{enumerate}
		\item Całościowa: stary system jest porzucany i wdrażany jest nowy (wysokie ryzyko, niskie koszty).
		\item Cząstkowa: stopniowe wdrażanie modułów systemu (średnie ryzyko, średnie koszty).
		\item Równoległa: wdrażanie nowego systemu, przy jednoczesnym podtrzymaniu starego (niskie ryzyko, wysokie koszty).	
	\end{enumerate}

	\section{Scharakteryzować podstawowe modele baz danych.}
	\begin{itemize}
		\item  \textbf{Hierarchiczny} - w tym modelu przechowywane dane są zorganizowane w postaci drzewa. Informacja jest zawarta w dokumentach oraz w strukturze drzewa (podobnej do drzewa folderów na dysku komputera).
		\item  \textbf{Sieciowy} - uogólniony model hierarchiczny, rekordy mogą przyjmować strukturę dowolnego grafu.
		\item  \textbf{Relacyjny} - rekordy są grupowane w relacje (tabele). Dla każdej relacji musi zostać wybrany klucz główny, jednoznacznie identyfikujący dany rekord. Klucz obcy pozwala na powiązanie relacji między sobą (skrót myślowy). Większość relacyjnych baz danych korzysta z języka zapytań SQL. W modelu relacyjnym abstrahujemy od kolejności wierszy (rekordów) i kolumn (pól w rekordzie). Wiersz reprezentuje jeden rekord informacji np. osobę. Liczba kolumn jest z góry ustalona. Z każdą kolumną jest związana jej nazwa oraz dziedzina, określająca zbiór wartości, jakie mogą wystąpić w kolumnie.
		\item  \textbf{Obiektowy} - dane przyjmują postać obiektów. W przeciwieństwie do modelu relacyjnego, rekordy i relacje między nimi przechowywane są bezpośrednio (w formie obiektów, czyli struktur zwanych klasami), bez podziału na wiersze i kolumny.
	\end{itemize}

	\section{Czym wyróżnia się rozproszonych system informatycznych od innych.}
	W rozproszonych systemach informatycznych obliczenia wykonywane są na wielu komputerach, w potencjalnie różnych lokalizacjach.

	\section{Porównaj metody analizy obiektowej i strukturalnej w projektowaniu systemów informatycznych.}
	\begin{itemize}
		\item W podejściu \textbf{strukturalnym} dąży się do formalnej analizy systemu. W wyniku tej analizy tworzone są hierarchiczne struktury, których elementami są procesy, dane i związki zachodzące między nimi. Cechą charakterystyczną tego podejścia jest oddzielne modelowanie danych i procesów, wykorzystujące diagramowe i macierzowe metody i techniki.
		\item Podstawową różnicą między podejściem strukturalnym a \textbf{obiektowym} jest zintegrowane, jednoczesne modelowanie danych i procesów dziedziny przedmiotowej. System w podejściu obiektowym stanowi kolekcję różnych rodzajów, wzajemnie powiązanych elementów zwanych obiektami, spełniających w nim określoną rolę. Pojęcia klasy i obiektu umożliwiły powiązanie atrybutów (danych) i operacji (usług) w elementy, które łatwo przenieść koncepcyjnie na obiekty świata rzeczywistego.
	\end{itemize}

	\section{Scharakteryzować standardowy język zapytań do baz danych.}
	\textbf{SQL} (\textit{Structured Query Language}) – strukturalny język zapytań używany do tworzenia, modyfikowania baz danych oraz do umieszczania i pobierania danych z baz danych. Język SQL jest językiem deklaratywnym. Decyzję o sposobie przechowywania i pobrania danych pozostawia się systemowi zarządzania bazą danych (DBMS).\\

	Użycie SQL, zgodnie z jego nazwą, polega na zadawaniu zapytań do bazy danych. Zapytania można zaliczyć do jednego z czterech głównych podzbiorów:
	\begin{itemize}
		\item SQL DML (ang. Data Manipulation Language – „język manipulacji danymi”)
			\begin{itemize}
				\item insert - umieszczenie danych
				\item update - zmiana danych
				\item delete - usunięcie danych
			\end{itemize}
		\item SQL DDL (ang. Data Definition Language – „język definicji danych”)
			\begin{itemize}
				\item create - utworzenie struktury
				\item drop - usunięcie struktury
				\item alter - zmiana struktury
			\end{itemize}
		\item SQL DCL (ang. Data Control Language – „język kontroli nad danymi”)
			\begin{itemize}
				\item grant - nadawanie uprawnień użytkownikowi 
				\item revoke - odbieranie wskazanych uprawnień konkretnemu użytkownikowi
				\item deny - zabranianie wykonywania operacji
			\end{itemize}
		\item SQL DQL (ang. Data Query Language – „język definiowania zapytań”)
			\begin{itemize}
				\item select
			\end{itemize}
	\end{itemize}

	\section{Na czym polega polimorfizm metod w programowaniu obiektowym i po co się go stosuje?}
	Polega na przedefiniowaniu metod klasy nadrzędnej w klasie pochodnej. Polimorfizm pozwala traktować różnorodne dane w ten sam sposób. Przykładowo mamy wiele klas (dziedziczących z jednej klasy abstrakcyjnej) dla różnych rodzajów figur geometrycznych a dla każdej z tych figur możemy policzyć jej pole. Polimorfizm pozwala nam w każdej z tych klas zaimplementować metodę wirtualną o takiej samej nazwie np. ObliczPole() i w zależności od typu obiektu w momencie wywołania metody zostanie wykonana ta prawidłowa. Pozwala to na odseparowanie implementacji od interfejsu, co z kolei ułatwia rozszerzanie funkcjonalności.

	\section{Wymienić i scharakteryzować metody testowania oprogramowania.}
	Ze względu na poziom szczegółowości:
		\begin{itemize}
			\item \textbf{Testy jednostkowe} - testowaniu podlegają najmniejsze elementy programu (np. pojedyncze funkcje).
			\item \textbf{Testy integracyjne} - testowaniu podlega komunikacja między komponentami systemu, w celu sprawdzenia poprawności interakcji między nimi.
			\item \textbf{Testy systemowe} - testowaniu podlega cały zintegrowany system w celu sprawdzenia, czy spełnia postawione mu wymagania.
			\item \textbf{Testy akceptacyjne} - sprawdzana jest gotowość systemu do wypuszczenia na rynek.
		\end{itemize}
	Ze względu na szczegóły implementacyjne:
		\begin{itemize}
			\item \textbf{Testy funkcjonalne (czarnej skrzynki)} - implementacja nie jest znana, testowana jest funkcjonalność i warstwa interfejsu systemu.
			\item \textbf{Testy strukturalne (białej skrzynki)} - implementacja jest znana, testowane są ścieżki przepływu sterowania (np. warunki).
		\end{itemize}

	\section{Wymienić metody ochrony danych w systemach baz danych.}
	\begin{multicols}{2}
		\begin{itemize}
			\item Kontrola dostępu,
			\item audyt wykonywanych operacji,
			\item uwierzytelnianie,
			\item szyfrowanie danych,
			\item kontrola integralności danych,
			\item kopie zapasowe,
			\item replikacja danych,
			\item mechanizm transakcji,
			\item ochrona w warstwie aplikacji.
		\end{itemize}
	\end{multicols}

	\section{Rola sterowników w dostępie do baz danych.}
	Sterowniki dla baz danych to programy implementujące protokół pozwalający na połączenie z bazą danych. Łączy interfejs użytkownika z konkretną bazą danych (np. JDBC, MySQL). Sterownik tłumaczy zapytania zadane przez użytkownika na język zrozumiały dla danego DBMS. Pozwala to na ujednolicenie interfejsu programistycznego komunikacji z systemami bazodanowymi.

	\section{Zarządzanie procesami w systemach operacyjnych.}
	Procesami zarządza planista (scheduler), który jest odpowiedzialny za rozpoczynanie, wznawianie i kończenie procesów oraz przełączanie kontekstu pomiędzy procesami. System operacyjny dostarcza mechanizmy umożliwiające komunikację między procesami oraz synchronizację. Planowanie procesów polega na wskazywaniu procesu, któremu ma być w danej chwili przydzielony procesor. W szczególności oznacza to decydowanie, kiedy i który proces ma przejść ze stanu gotowy do stanu aktywny. W systemie w każdej chwili może być aktywnych co najwyżej tyle procesów ile jest procesorów. W każdej chwili proces jest w jakimś stanie. Ten stan zmienia się w miarę postępu wykonania procesu. Oto możliwe stany:
	
	\begin{itemize}
		\item \textbf{Nowy} (proces właśnie utworzono) - może przejść jedynie do stanu gotowy. Dzieje się tak, gdy system załaduje program do pamięci.
		\item \textbf{Aktywny} (proces jest właśnie wykonywany przez procesor) - może przejść do jednego z trzech stanów:
		\begin{itemize}
			\item gotowy - gdy planista odbierze procesowi procesor,
			\item czekający - gdy proces rozpocznie oczekiwanie na jakieś zdarzenie, np. zleci operację wejścia-wyjścia i czeka na jej wykonanie,
			\item zakończony - gdy proces zakończy działanie.
		\end{itemize}
		\item \textbf{Czekający} - proces czeka na zajście jakiegoś zdarzenia (np. wykonanie operacji wejścia-wyjścia) -  może przejść jedynie do stanu gotowy. Dzieje się tak, gdy nastąpi oczekiwane przezeń zdarzenie, np. ukończenie operacji wejścia-wyjścia.
		\item \textbf{Gotowy} (proces czeka na przydzielenie mu procesora) - może przejść jedynie do stanu aktywny. Dzieje się tak, gdy moduł systemu operacyjnego zwany planistą przydzieli temu procesowi procesor.
		\item \textbf{Zakończony} (proces zakończył działanie) - nie może już zmienić swojego stanu.
	\end{itemize}

	\section{Co to jest system komputerowy, informacyjny, informatyczny.}
	\begin{itemize}	
		\item \textbf{System komputerowy} - sprzęt i oprogramowanie do przetwarzania danych. 
		\item \textbf{System informacyjny} - system, który przetwarza dane w informacje, gromadzi je i przesyła. 
		\item \textbf{System informatyczny} - część systemu informacyjnego, wykorzystująca system komputerowy.
	\end{itemize}

	\section{Powody tworzenia systemów rozproszonych.}
	\begin{itemize}
		\item \textbf{Dzielenie zasobów} (ang. resource sharing) – wielu użytkowników systemu może korzystać z danego zasobu (np. drukarek, plików, usług, itp.).
		
		\item \textbf{Otwartość} (ang. openness) – podatność na rozszerzenia, możliwość rozbudowy systemu zarówno pod względem sprzętowym, jak i oprogramowania.
		
		\item \textbf{Współbieżność} (ang. concurrency) – zdolność do przetwarzania wielu zadań jednocześnie.
		
		\item \textbf{Skalowalność} (ang. scalability) – cecha systemu umożliwiająca zachowanie podobnej wydajności systemu przy zwiększaniu skali systemu (np. liczby procesów, komputerów, itp.).
		
		\item \textbf{Tolerowanie awarii} (ang. fault tolerance) – właściwość systemu umożliwiająca działania systemu mimo pojawiania się błędów i (lub) uszkodzeń (np. przez utrzymywanie nadmiarowego sprzętu).
		
		\item \textbf{Przezroczystość} (ang. transparency) – właściwość systemu powodująca postrzeganie systemu przez użytkownika jako całości, a nie poszczególnych składowych.
	\end{itemize}

	\section{Środowiska programistyczne stosowane do obliczeń inżynierskich.}
	MathWorks MATLAB, StatSoft Statistica,  Wolfram Mathematica, język i środowisko R, ...

	\section{Rodzaje systemów operacyjnych (klasyfikacja i charakterystyka).}
	\begin{itemize}
		\item Klasyfikacja ze względu na sposób przetwarzania:
		\begin{itemize}
			\item Systemy przetwarzania bezpośredniego - użytkownik wprowadza zadanie do systemu i oczekuje na wyniki. W trakcie przetwarzania jest zatem możliwa interakcja pomiędzy użytkownikiem a systemem (aplikacją). Użytkownik może być na przykład poproszony o wprowadzenie jakiś danych na terminalu, wybranie czegoś z menu itp.
			\item Systemy przetwarzania pośredniego -  zadanie jest realizowane w czasie wybranym przez system. Po przedłożeniu zadania ingerencja użytkownika jest niemożliwa. Wszystkie dane muszą być zatem dostępne w momencie przedkładania zadania, a jakikolwiek błąd programowy (np. niekompletność danych) oznacza konieczność przedłożenia i wykonania zadania ponownie.
		\end{itemize}
	
		\item Klasyfikacja ze względu na liczbę wykonywanych programów:
		\begin{itemize}
			\item  Systemy jednozadaniowe — niedopuszczalne jest rozpoczęcie wykonywania następnego zadania użytkownika przed zakończeniem poprzedniego.
			\item Systemy wielozadaniowe — dopuszczalne jest istnienie jednocześnie wielu zadań (procesów), którym zgodnie z pewną strategią przydzielany jest procesor.
		\end{itemize}
	
		\item Klasyfikacja ze względu na liczbę użytkowników:
		\begin{itemize}
			\item Systemy dla jednego użytkownika — zasoby przeznaczone są dla jednego użytkownika (np. w przypadku komputerów osobistych), nie ma mechanizmów autoryzacji, a mechanizmy ochrony informacji są ograniczone.
			\item Systemy wielodostępne — wielu użytkowników może korzystać ze zasobów systemu komputerowego, a system operacyjny gwarantuje ich ochronę przed nieupoważnioną ingerencją.
		\end{itemize}
	
		\item Inne:
		\begin{itemize}
			\item Systemy czasu rzeczywistego (ang. real-time systems) zorientowane na przetwarzanie z uwzględnieniem czasu zakończenie zadania, tzw. linii krytycznej (ang. deadline).
			\item Systemy sieciowe i rozproszone (ang. network and distributed systems) — umożliwiają zarządzanie zbiorem rozproszonych jednostek przetwarzających, czyli zbiorem jednostek (komputerów), które są zintegrowane siecią komputerową i nie współdzielą fizycznie zasobów.
			\item Systemy operacyjne komputerów naręcznych — tworzone dla rozwiązań typu PDA, czy telefonów komórkowych, podlegają istotnym ograniczeniom zasobowym.
		\end{itemize}
	\end{itemize}

	\section{Podać klasyfikację języków programowania.}
	Ze względu na generację:	
	\begin{itemize}
		\item \textbf{1GL}: poziom maszynowy; języki maszynowe, czyli języki procesorów. Instrukcje są w nich zapisywane w postaci liczb binarnych. 
		\item \textbf{2GL}: poziom niski (assemblerowy); języki symboliczne, asemblery. Języki niskiego poziomu, pod względem składni tożsame z maszynowymi.
		\item \textbf{3GL}: języki wysokiego poziomu; proceduralne (imperatywne). W językach tych jedna instrukcja jest tłumaczona na kilka instrukcji procesora, najczęściej od 5 do 10. Pierwszym językiem tego typu był ALGOL. Do tej grupy należą między innymi: FORTH, BASIC - języki niestrukturalne, Pascal, C, FORTRAN - języki strukturalne, C++, Java - języki zorientowane obiektowo. 
		\item \textbf{4GL}: języki zadaniowe (SQL, Excel);  języki bardzo wysokiego poziomu, nieproceduralne (deklaratywne). Korzystając z tych języków programista skupia się na problemie, a nie na sposobie jego rozwiązania (języki zorientowane problemowo, ang. task oriented languages). Syntaktyka wielu języków czwartej generacji przypomina składnię języka naturalnego. Są one często używane do dostępu do baz danych. Przykładem języka z tej grupy jest: SQL. 
		\item \textbf{5GL}: wizualny interface;  języki sztucznej inteligencji, języki systemów ekspertowych. Języki najbardziej zbliżone do języka naturalnego. Przykładem języka piątej generacji jest PROLOG.
	\end{itemize}

	Ze względu na paradygmat programowania:	
	\begin{itemize}
		\item \textbf{deklaratywne} - programista opisuje warunki, jakie musi spełniać końcowe rozwiązanie (co chcemy osiągnąć), a nie szczegółową sekwencję kroków, które do niego prowadzą (jak to zrobić). Przykładami są takie języki jak Prolog, SQL i VDM (SQL jest właściwie proceduralno-deklaratywny, hybrydowy). Przykład (na bazie SQL): \textit{select nazwisko from pracownicy where salary < 3000}
		\begin{itemize}
			\item \textbf{logiczne} - metoda programowania, będąca odmianą programowania deklaratywnego, w której program podawany jest jako pewien zestaw zależności, a obliczenia są dowodem pewnego twierdzenia w oparciu o te zależności.
			\item \textbf{funkcyjne} - filozofia i metodyka programowania będąca odmianą programowania deklaratywnego, w której funkcje należą do wartości podstawowych, a nacisk kładzie się na wartościowanie (często rekurencyjnych) funkcji, a nie na wykonywanie poleceń.
		\end{itemize}
		\item \textbf{imperatywne} - opisuje proces wykonywania jako sekwencję instrukcji zmieniających stan programu. Programy imperatywne składają się z ciągu komend do wykonania przez komputer. Przykłady: FORTRAN i ALGOL (niektórzy też wliczają Pascal, C, Ada).
		\begin{itemize}
			\item \textbf{proceduralne} - paradygmat programowania zalecający dzielenie kodu na procedury, czyli fragmenty wykonujące ściśle określone operacje. Procedury nie powinny korzystać ze zmiennych globalnych (w miarę możliwości), lecz pobierać i przekazywać wszystkie dane (czy też wskaźniki do nich) jako parametry wywołania. Dane i procedury nie są ze sobą bezpośrednio związane
			\item \textbf{obiektowe} - programy definiuje się za pomocą obiektów – elementów łączących stan (pola) i zachowanie (metody). Obiektowy program komputerowy wyrażony jest jako zbiór takich obiektów, komunikujących się pomiędzy sobą w celu wykonywania zadań.
		\end{itemize}			
		\item \textbf{strukturalne} - paradygmat programowania opierający się na podziale kodu źródłowego programu na procedury i hierarchicznie ułożone bloki z wykorzystaniem struktur kontrolnych w postaci instrukcji wyboru i pętli. 
	\end{itemize}
	
	Sposób wykonywania:
		\begin{itemize}
			\item interpretowane (JS, PHP)
			\item kompilowane (C, C++, Java)
		\end{itemize}

	\section{Paradygmaty programowania obiektowego.}
	\begin{itemize}
		\item \textbf{Abstrakcja} - każdy obiekt w systemie służy jako model abstrakcyjnego "wykonawcy", który może wykonywać pracę, opisywać i zmieniać swój stan, oraz komunikować się z innymi obiektami w systemie, bez ujawniania, w jaki sposób zaimplementowano dane cechy.
		
		\item \textbf{Hermetyzacja} - oddzielenie „co” od „jak”. Enkapsulacja zapewnia, że obiekt nie może zmieniać stanu innych obiektów w nieokreślony sposób. Każdy typ obiektu dostarcza interfejsu, który określa sposób współpracy z innymi obiektami. Jedynie za pomocą określonych metod mamy możliwość zmienić stan obiektu, bezpośredni dostęp do zmiennych jest zabroniony.
		
		\item \textbf{Dziedziczenie(kompozycja)} - umożliwia stworzenie hierarchii obiektów w programie. Polega na przejęciu właściwości i funkcjonalności obiektów innej klasy i ewentualnej modyfikacji tych właściwości i funkcjonalności w taki sposób, by były one bardziej wyspecjalizowane.
		
		\item \textbf{Polimorfizm(wielopostaciowość)} - referencje i wskaźniki obiektów mogą dotyczyć obiektów różnego typu, a wywołanie metody dla referencji spowoduje zachowanie odpowiednie dla pełnego typu obiektu wywoływanego. Zazwyczaj można wyróżnić dwa rodzaje polimorfizmu: dynamiczne- wykonywane podczas działania programu, a także statyczne- na etapie kompilacji.
	\end{itemize}

	\section{Zadania systemu zarządzania bazami danych (DBMS).}
	\begin{itemize}
		\item tworzenie struktury bazy danych oraz tabel
		\item realizacja zapytań
		\item dodawanie, usuwanie i modyfikacja danych
		\item kontrola redundancji danych
		\item kontrola użytkowników i autoryzacja
		\item zarządzanie transakcjami
	\end{itemize}

	\section{Topologie sieci komputerowych.}
	Budowa (topologia) warunkowana jest przez zastosowanie sieci. Najprostsze komunikowanie się sieci można zrealizować przez jedynie połączenie komputerów, w innych przypadkach używa się urządzeń kierujących ruchem.
		
	\begin{itemize}
		\item \textbf{Topologia magistrali} (szyny, linii) - połączone jednym, współdzielonym medium.
		\begin{itemize}
			\item Zalety:
			\begin{itemize}
				\item Brak koncentratorów/przełączników
				\item Awaria węzła nie powoduje paraliżu sieci
			\end{itemize}
			\item Wady:
			\begin{itemize}
				\item Awaria kabla powoduje paraliż sieci
				\item Ograniczona możliwość rozbudowy
				\item Niska przepustowość
				\item Obsługuje tylko jeden kanał transmisyjny
			\end{itemize}
		\end{itemize}
	
		\item \textbf{Topologia gwiazdy} - posiada punkt centralny (switch, koncentrator) i gwiaździście połączone do niego komputery.
		\begin{itemize}
			\item Zalety:
			\begin{itemize}
				\item Bardzo łatwa rozbudowa sieci
				\item Awaria węzła nie powoduje paraliżu sieci
				\item Wysoka przepustowość
			\end{itemize}
			\item Wady:
			\begin{itemize}
				\item Ograniczenie odległości stacji roboczej od koncentratora
				\item Uszkodzenie koncentratora powoduje całkowity paraliż sieci
			\end{itemize}
		\end{itemize}
		
		\item \textbf{Topologia pierścienia} - komputery połączone są za pomocą jednego nośnika informacji w układzie zamkniętym - okablowanie nie ma żadnych zakończeń (tworzy krąg).
		\begin{itemize}
			\item Zalety:
			\begin{itemize}
				\item Niskie koszty budowy
			\end{itemize}
			\item Wady:
			\begin{itemize}
				\item Niska przepustowość
				\item Trudna do rozbudowy
				\item Ciężka lokalizacja uszkodzeń
				\item Uszkodzenie jednej stacji powoduje paraliż sieci
			\end{itemize}
		\end{itemize}
		
		\item \textbf{Rozszerzone topologie}:
		\begin{itemize}
			\item \textbf{Topologia siatki}
			\item \textbf{Topologia gwiazdy rozszerzonej} – posiada punkt centralny (podobnie do topologii gwiazdy) i punkty poboczne (jedna z częstszych topologii fizycznych Ethernetu)
			\item \textbf{Topologia podwójnego pierścienia} – poszczególne elementy są połączone pomiędzy sobą odcinkami tworząc dwa zamknięte pierścienie
			\item \textbf{Topologia siatki} – oprócz koniecznych połączeń sieć zawiera połączenia nadmiarowe; rozwiązanie często stosowane w sieciach, w których wymagana jest bezawaryjność
		\end{itemize}
	\end{itemize}

	\section{Podstawowe składniki sprzętowe w sieciach komputerowych.}
	terminal, urządzenia transmisji (np. kable), karta sieciowa, modem, switch, router, hub, most, ...

	\section{Zastosowania mikroprocesorów.}
	\begin{itemize}
		\item elektronika przemysłowa - sterowniki PLC,
		\item elektronika powszechnego użytku - telefony komórkowe, zegarki, komputery
		\item telekomunikacja - routery, switche etc.,
		\item technika samochodowa - piloty, sterowniki świateł, lusterek, radia, kontrolery wtrysku,
		\item medycyna - ciśnieniomierze, EKG, USG, termometry, mierniki poziomu cukru we krwi,
		\item automatyka budynków - sterowniki klimatyzacji i rolet.
	\end{itemize}

	\section{Metody kompresji danych.}
	\begin{itemize}
		\item \textbf{bezstratna}, np. kodowanie Huffmana, PNG: w której z postaci skompresowanej można odzyskać identyczną postać pierwotną, bajty występujące częściej mają krótszą reprezentację niż te występujące rzadziej. 
		\item \textbf{stratna} - w której takie odzyskanie jest niemożliwe, jednak główne właściwości zostają zachowane, może dotyczyć różnych sygnałów (np. dźwięk, obraz), np. kompresja falkowa,kodowanie transformatorowe, JPEG, mp3.
	\end{itemize}

	\section{Sprzętowe środki przyspieszania obliczeń.}
	\begin{itemize}
		\item Wykorzystanie wielu rdzeni procesora.
		\item Wykorzystanie obliczeń na karcie graficznej GPGPU - (ang. general-purpose computation on graphics processing units) obliczenia ogólnego przeznaczenia na układach GPU, zwany także GPGP, rzadziej GP2. Technika, dzięki której GPU, zwykle zajmujący się tylko obliczeniami związanymi z grafiką komputerową, umożliwia wykonywanie obliczeń ogólnego przeznaczenia, tak jak CPU. Dzięki temu wiele obliczeń, głównie obliczenia równoległe, można przeprowadzić znacznie szybciej.
		\item Wykorzystanie układów FPGA, ASIC
		\begin{itemize}
			\item FPGA (ang. Field-Programmable Gate Array) - jeden z rodzajów układów PLD. Układy FPGA zawierają w sobie matrycę programowalnych bloków logicznych i konfigurowalnych połączeń między nimi. Układy FPGA ze względu na poziom skomplikowania oraz możliwości tych układów określa się jako najbardziej zaawansowane ze wszystkich rodzin PLD.
			\item ASIC (ang. Application Specific Integrated Circuit) - rodzaj układów scalonych, w których nie ma możliwości ich rekonfiguracji. Ich zaletami jest to, że wykonują funkcje szybciej i przy mniejszym użyciu zasobów niż w przypadku np. mikrokontrolerów. Układy ASIC mieszczą w sobie często kompletne funkcjonalności dla których byłoby konieczne użycie mikrokontrolera i dodatkowych układów, co umożliwia stworzenie kompletnego urządzenia w jednym chipie.
		\end{itemize}
	\end{itemize}

	\section{Klasyfikacja usług internetowych.}
	\begin{itemize}
		\item pocztowe (POP3, SMTP),
		\item transferu plików (FTP),
		\item terminalowe (SSH),
		\item serwisów informacyjnych (HTTP)
		\item telefonia internetowa (VoIP)
	\end{itemize}

	\section{Budowa procesora (CPU).}
	Jeśli chodzi o budowę fizyczną, mikroprocesor to nic innego jak krzemowa płytka z milionem tranzystorów, które blokują lub umożliwiają przepływ prądu. Z tranzystorów budowane są bramki logiczne, a te z kolei są łączone w bardziej rozbudowane układy.
	
	\begin{itemize}
		\item \textbf{ALU} (ang. Arithmetic Logic Unit) - wykonuje podstawowe operacje arytmetyczne (dodawanie, odejmowanie, dzielenie oraz mnożenie oraz logiczne (OR, AND, XOR, NOT) oraz przesunięcia bitowe. ALU współpracuje z roboczym rejestrem zwanym akumulatorem (lub wieloma akumulatorami), który przechowuje jeden z operandów (argumentów) wykonywanej operacji oraz wyniku tej operacji.
		
		\item \textbf{CU} (ang. Control Unit) - dekoduje zawartość rejestru rozkazów i generuje odpowiednie sygnały sterujące zapewniające prawidłowy przebieg operacji zdefiniowanej kodem rozkazu.
		
		\item \textbf{Rejestry} (ang. Register) - komórki pamięci do przechowywania tymczasowych wyników obliczeń, adresów lokacji w pamięci RAM itp. Rejestry są najszybszym rodzajem pamięci.
		\begin{itemize}
			\item \textbf{Rejestr instrukcji IR} (ang. Instruction Register) - przechowuje aktualnie wykonywaną instrukcję.
			\item\textbf{ Licznik rozkazów PC} (ang. Program Counter) - przechowuje adres w pamięci, gdzie przechowywany jest kolejny rozkaz do pobrania. Rozkazy są przechowywane w postaci kodów binarnych.
			\item \textbf{Akumulator A} (ang. Accumulator) - przechowuje argument (operand) do operacji ALU lub wynik operacji.
			\item \textbf{Wskaźnik stosu SP} (ang. Stack Pointer) - wskazuje na szczyt stosu (adres ostatniej zapełnionej komórki stosu).
			\item \textbf{Rejestr flagowy} - przechowuje informacje dotyczące operacji ALU np. flaga przeniesienia lub pożyczki CF (ang. Carry Flag), flaga parzystości PF (ang. Parity Flag), flaga przepełnienia OF (ang. Overflow Flag) itp.
		\end{itemize}
		
		\item \textbf{Magistrale} (ang. Bus) - wewnętrzne szyny łączące.
		\begin{itemize}
			\item \textbf{szyna danych} (ang. data bus) - magistrala komunikacyjna wykorzystywana d przesyłania właściwych danych,
			\item \textbf{szyna adresowa} (ang. address bus) - łączy CPU z pamięcią. Określa pod jaki adres mają zostać wysłane dane szyną danych. Szerokość magistrali (liczba linii) określa maksymalną pojemność pamięci systemu (przestrzeń adresową)
			\item \textbf{szyna sterująca} (ang. control bus) - zapewnia regulację dostępu do szyny adresowej i szyny danych.
		\end{itemize}
	\end{itemize}

	\section{Technologie tworzenia stron internetowych.}
		\begin{multicols}{2}
		\begin{itemize}
			\item PHP
			\item HTML
			\item CSS
			\item JavaScript
			\item MySQL
			\item jQuery
			\item Flash
			\item WordPress
			\item Joomla
		\end{itemize}
	\end{multicols}

	\section{Czym różnią się portal i wortal internetowy.}
	\textbf{Portal internetowy} jest to serwis informacyjny, na którym jest poruszanych wiele tematów z życia. Taki portal zawiera między innymi: aktualności z kraju i ze świata, prognozę pogody czy katalog wyszukiwarek.\\
	Z kolei \textbf{wortale} internetowe są to takie strony, na których zazwyczaj poruszany jest jeden temat lub pewien zakres tematyczny.

	\section{Przetwarzanie rozproszone – charakterystyka.}
	Przetwarzanie danych równolegle przez wiele komputerów o możliwie różnej lokalizacji. Informacje między komputerami wymieniane są sporadycznie. Charakteryzuje się dużą wydajnością, skalowalnością i niezawodnością. Szczególny przypadek przetwarzania równoległego.

	\section{Przetwarzanie równoległe – charakterystyka.}
	Przetwarzanie danych równolegle przez jeden lub więcej komputerów. Procesy wykonywane są równocześnie. W przypadku wykonywania zadania na jednym komputerze, konieczna jest utylizacja wielu procesorów. Ze względu na skalę można wyróżnić obliczenia równoległe na poziomie: bitów, instrukcji, danych, zadań. Do prowadzenia obliczeń równoległych, oprócz sprzętu, konieczne są również odpowiednie algorytmy nazywane równoległymi. Są one trudniejsze w implementacji niż sekwencyjne, ponieważ współbieżność wprowadza dodatkowe możliwości popełnienia błędu. Powstają również dodatkowe problemy w uzyskaniu wysokiej wydajności z powodu dodatkowych nakładów na komunikację i konieczność synchronizacji obliczeń.

	\section{Grafika rastrowa a grafika wektorowa.}
	\begin{itemize}
		\item \textbf{rastrowa} - obraz przedstawiony jest jako macierz pikseli
		\item \textbf{wektorowa} - obraz zdefiniowany jest jako zbiór opisanych matematycznie figur geometrycznych
	\end{itemize}

	\section{Porównanie modeli odniesienia: ISO/OSI oraz TCP/IP.}
	Model TCP/IP określany jest jako model protokołów. Każda z jego warstw wykonuje konkretne zadania, do realizacji który wykorzystywane są konkretne protokoły. Model ISO/OSI natomiast zwany modelem odniesienia, stosowany jest raczej do analizy, która pozwala lepiej zrozumieć procesy komunikacyjne zachodzące w sieci oraz stanowi wzór do projektowania rozwiązań sieciowych zarówno sprzętowych jak i programowych.\\
	Oba modele są do siebie dość podobne. Różnice jakie występują widoczne są w górnych warstwach gdzie w przypadku modelu ISO/OSI dokonano podziału, aż na 3 warstwy, a w przypadku modelu TCP/IP te same funkcje realizowane jest tylko poprzez jedną warstwę. Podobne różnice widać w dolnych warstwach, gdzie w modelu ISO/OSI mamy dwie oddzielne warstwy łącza danych i fizyczną, a w przypadku modelu TCP/IP tylko jedną, warstwę dostępu do sieci.
	
	\begin{multicols}{2}
		\begin{itemize}
			\item \textbf{ISO/OSI}:
			\begin{enumerate}
				\item Aplikacji
				\item Prezentacji
				\item Sesji
				\item Transportowa
				\item Sieciowa
				\item Łącza danych
				\item Fizyczna	
			\end{enumerate}
		
			\columnbreak
			
			\item \textbf{TCP/IP}:
			\begin{enumerate}
				\item Aplikacji (OSI 3, 2, 1)
				\item Transportowa (OSI 4)
				\item Internetowa (OSI 5)
				\item Dostępu do sieci (OSI 6, 7)
			\end{enumerate}
		
			\vfill\null
		\end{itemize}
	\end{multicols}
	
	\section{Zadania warstwy transportowej.}
	\begin{itemize}
		\item nawiązanie i obsługa połączeń (sesji) pomiędzy hostami,
		\item śledzenie połączeń pomiędzy hostami,
		\item segmentowanie danych,
		\item identyfikowanie poszczególnych aplikacji,
		\item kontrola przepływu danych,
		\item retransmisja w przypadku utraty danych.
		\item wykorzystywane protokoły TCP (Transmission Control Protocol) i UDP (User Datagram protocol)
	\end{itemize}

	\section{Charakterystyka warstwy fizycznej.}
	Odbiera ramki danych z warstwy 6, czyli warstwy łącza danych, i przesyła szeregowo, bit po bicie, całą ich strukturę oraz zawartość przez medium transmisyjne. Jest ona również odpowiedzialna za odbiór kolejnych bitów przychodzących strumieni danych. Określa w jaki sposób bity są przedstawiane w formie impulsów napięciowych, świetlnych czy też sygnałów radiowych. Kodowane bity mogą być reprezentowane poprzez zmiane amplitudy, częstotliwości lub fazy.\\	
	W specyfikacji warstwy fizycznej są opisane takie cechy jak napięcia elektryczne, taktowania zegarów, szybkość i maksymalne odległości transmisji. Warstwa fizyczna używa czterech procesów (adresowanie, enkapsulacja, routing, dekapsulacja).

	\section{Charakterystyka warstwy łącza danych.}
	\begin{itemize}
		\item zasadniczą rolą warstwy łącza danych jest zapewnienie warstwom górnym dostępu do medium transmisyjnego, umieszcza w nośniku dane pochodzące z warstw wyższych
		\item nadzoruje jakość przekazywanych informacji w warstwie niższej (fizycznej)
		\item rozpoznaje błędy związane z gubieniem pakietów i uszkodzeniem ramek oraz zajmuje się ich naprawą
		\item zachodzi enkapsulacja pakietów z warstwy sieciowej tak, aby uzyskać ramki zgodne ze standardem
		\item dodaje do pakietów adres MAC
	\end{itemize}

	\section{Do czego służy protokół TCP, a do czego IP?}
	\begin{itemize}
		\item \textbf{TCP} - Aplikacje, które wymagają od protokołu transportowego niezawodnego dostarczania danych, używają protokołu TCP. Protokół ten sprawdza, czy dane dokładnie dotarły do miejsca przeznaczenia i czy zrobił to we właściwej kolejności. TCP zapewnia niezawodność za pomocą mechanizmu zwanego pozytywne potwierdzenie z retransmisją – wysyła on dane ponownie, dopóki nie otrzyma informacji, że dane zostały poprawnie odebrane. Jednostka danych wymieniana między współpracującymi modułami TCP nosi nazwę segmentu.
		\item \textbf{IP} - jest protokołem komunikacyjnym warstwy Internet w modelu TCP/IP (odpowiada warstwie sieciowej modelu OSI). Protokół ten definiuje zasady i sposoby postępowania urządzeń sieciowych w celu nawiązania połączenia, utrzymania go i samej transmisji danych. Protokół IP stosowany jest w większości rodzajów sieci, w tym w sieci lokalnej i sieci Internet (każdy host, np. komputer, posiada swój własny, unikalny dla sieci adres IP). Dane z użyciem protokołu IP transmitowane są w pakietach (paczkach danych). Nie gwarantuje on jednak dotarcia danych do celu czy utrzymania kolejności pakietów. Może się zdarzyć, ze odbiorca otrzyma kilkukrotnie ten sam pakiet z całej paczki danych, pakiety dotrą w innej kolejności lub nie dotrą w ogóle. W celu zapewnienia prawidłowej transmisji stosuje się różne techniki w wyższej warstwie, np. z użyciem protokołu TCP.
	\end{itemize}

	\section{Rodzaje światłowodów - wady, zalety.}
	\begin{itemize}
		\item szklany: duże odległości, wielkie prędkości
		\item plastikowy: tani, małe prędkości, małe odległości
		\item krzemianowy: nieznacznie lepszy od plastikowego
		\item jednomodowy: bardzo drogi, duże odległości, trudny w obsłudze
		\item wielomodowy (fala o takiej samej długości fali może rozchodzić się wieloma drogami, zwanymi modami): drogi, średnie odległości
	\end{itemize}

	\section{Scharakteryzować sieciowe systemy plików.}
	\label{sec:siecsysplik}
	Umożliwia dostęp do danych komputerom zdalnym. Dane znajdują się na jednym lub wielu serwerach. Charakteryzuje je m.in.:
	\begin{itemize}
		\item przeźroczystość dostępu: dostęp do plików jest taki sam jak dla plików lokalnych
		\item przeźroczystość lokacji: pliki zdalne i lokalne łączy jedna przestrzeń -- nazwa pliku nie określa jego lokacji
		\item przeźroczystość współbieżności: stan systemu plików jest taki sam dla wszystkich klientów
	\end{itemize}

	Przykładowe sieciowe systemy plików:
	\begin{itemize}
		\item \textbf{NCP} - służy do uzyskiwania dostępu do plików, katalogów, drukarek sieciowych, synchronizacji zegara systemowego, zarządzania pocztą elektroniczną, zdalnego wywoływania poleceń w trybie terminalowym i innych usług sieciowych. W Novell eDirectory NCP używany jest do synchronizacji wymiany danych między serwerami.
		\item \textbf{NFS} – oparty na UDP lub TCP protokół zdalnego udostępniania systemu plików. Z NFS wiąże się wiele problemów – przede wszystkim bardzo trudno zapewnić, że dana operacja została wykonana. Jeśli między odebraniem żądania a wysłaniem potwierdzenia wystąpi błąd, klient może się nie dowiedzieć, czy operacja została wykonana.
	\end{itemize}

	\section{Wymień i opisz warstwy modelu OSI.}
	\begin{enumerate}
	\item \textbf{Warstwa fizyczna.} Jest odpowiedzialna za transmisję strumienia bitów między węzłami sieci. Definiuje protokoły opisujące interfejsy fizyczne. Do funkcji tej warstwy należą: sprzęgniecie z medium transmisji danych, dekodowanie sygnałów, określanie zakresu amplitudy prądu lub napięcia i określanie parametrów mechanicznych łączówek (kształtu, wymiarów i liczby styków) oraz inne kwestie związane z transmisją bitów. 
	\item \textbf{Warstwa łącza danych.} Zapewnia niezawodne łącze pomiędzy sąsiednimi węzłami. Nadzoruje przepływ informacji przez łącze i w związku z podatnością warstwy fizycznej na zakłócenia i wynikające stąd błędy oferuje własne mechanizmy kontroli błędów w przesyłanych ramkach lub pakietach.
	\item \textbf{Warstwa sieciowa.} Dostarcza środków do ustanawiania, utrzymania i rozłączania połączeń sieciowych miedzy systemami otwartymi, w których rezydują komunikujące się aplikacje, i odpowiada, za obsługę błędów komunikacji. Ponadto warstwa sieciowa jest odpowiedzialna za funkcje routingu, który wyznacza optymalną pod względem liczby połączeń drogę przesyłania pakietu przez sieć.
	\item \textbf{Warstwa transportowa.} Zapewnia przezroczysty transfer danych między stacjami sesyjnymi, odciąża je od zajmowania się problemami niezawodnego i efektywnego pod względem kosztów transferu danych. Warstwa ta zapewnia usługi połączeniowe. Wszystkie protokoły w warstwie transportowej są typu end-to-end. Oznacza to, że działają one tylko między końcowymi systemami otwartymi.
	\item \textbf{Warstwa sesji.} Umożliwia aplikacjom organizację dialogu oraz wymianę danych między nimi. Do najważniejszych usług warstwy sesji należą: sterowanie wymianą danych, ustalanie punktów synchronizacji danych (dla celów retransmisji w wypadku przemijających przekłamań na łączach) oraz umożliwienie odzyskania danych (utraconych w wyniku przerwy w łączności) przez ponowne ich przesłanie.
	\item \textbf{Warstwa prezentacji.} Zapewnia możliwość reprezentowania informacji, którą się posługują stacje aplikacyjne podczas komunikacji Zapewnia tłumaczenie danych, definiowanie ich formatu oraz odpowiednią składnię.
	\item \textbf{Warstwa aplikacji.} Dostarcza procesom aplikacyjnym metod dostępu do środowiska OSI, pełni rolę okna między współdziałającymi procesami aplikacyjnymi.
	\end{enumerate}

	\section{Podstawowe cechy standardów sieci bezprzewodowych WiFi.}
	\begin{itemize}
		\item \textbf{802.11a} - do 54Mbit/s, 5GHz. 802.11a obejmuje 12 niezachodzących kanałów, 8 przeznaczonych do pracy w budynkach oraz 4 przeznaczone do pracy między dwoma punktami (ang. point to point). 
		\item \textbf{802.11b} - 11Mbit/s, 2.4GHz, zasięg 30-120m. Standard 802.11b wykorzystuje algorytmy do usuwania zakłóceń generowanych przez sygnały zagłuszające oraz unikania kolizji podczas komunikacji wielu radiowych kart sieciowych.
		\item \textbf{802.11g} - 54Mbit/s, 2.4GHz, najpopulardniejszy standard, wymaga silnego i stabilnego sygnału względem 802.11b,
		\item \textbf{802.11n} - 300Mbit/s, 5GHz lub 150Mbit/s, 2.4GHz, wymaga silnego i stabilnego sygnału.
		\item \textbf{802.11ac} - Według specyfikacji IEEE 802.11ac przepustowość przy zastosowaniu wielu stacji ma być na poziomie przynajmniej 1 Gbit/s, a pojedynczej stacji 500 Mbit/s. Urządzenia standardu 802.11ac pracują na częstotliwości 5 GHz. MIMO, beamforming, 256-QAM.
	\end{itemize}

	\section{Przedstawić budowę światłowodu.}
	Od najbardziej wewnętrznej warstwy:	
	\begin{enumerate}
		\item rdzeń (włókno szklane), 
		\item płaszcz (materiał o niższym współczynniku załamania światła), 
		\item powłoka lakierowana (chroni płaszcz), 
		\item powłoka wzmacniająca (płaszcz ochronny) (ochrona przed wpływem środowiska)
		\item wzmocnienie
		\item osłona zewnętrzna
	\end{enumerate}

	\section{Cechy charakterystyczne cyfrowych sieci ISDN.}
	ISDN to sieć cyfrowa ze zintegrowanymi usługami. W sieciach ISDN nie występują pośredniczące urządzenia analogowe. Połączenia w ISDN są komutowane (zestawiane). Cechy to:
	
	\begin{itemize}
		\item przekaz cyfrowy
		\item gwarantowana przepływność, bez względu na odległość
		\item szybkie zestawianie połączeń
		\item można likwidować połączenia zaraz po realizacji sesji
		\item szeroki zakres usług wideotelefonii
		\item transmisja z komutacją obwodów oraz pakietów
		\item korzystanie ze standardowych (istniejących i komutowanych) linii telefonicznych dla dostępu podstawowego
	\end{itemize}

	\section{Rodzaje i zastosowania macierzy dyskowych.}
	\begin{itemize}
		\item \textbf{RAID 0.} Charakteryzuje się przyśpieszeniem pracy systemu. W RAID 0 łączymy ze sobą dwa (lub więcej) dyski fizyczne w jeden logiczny napęd. Przykładowo łącząc ze sobą dwa dyski po 500 GB, otrzymamy jeden dysk wielkości 1000 GB, a dane będą zapisywane jednocześnie na obu dyskach, co znacznie przyśpieszy prędkość i odczyt danych. Wadą RAID 0 jest to, że dane nie są zabezpieczone w żaden sposób. Jeśli jeden dysk ulegnie uszkodzeniu, traci się wszystkie dane.
		\item \textbf{RAID 1.} Składa się również z dwóch dysków twardych połączonych ze sobą. Ale w przeciwieństwie do RAID 0, dane na dyskach są zapisywane równolegle na każdym dysku. Czyli towrzy się tak jakby lustro (mirror) danych. Jest to podstawowe zabezpieczenie przed utratą danych - jeśli jeden z dysków ulegnie awarii, wtedy system nadal może działać, gdyż takie same dane są na drugim działającym dysku. Utworzona macierz ma pojemność równą wielkości najmniejszego dysku.
		\item \textbf{RAID 0+1.} Jest to kombinacja dwóch pierwszych rodzajów macierzy. Dwie macierze RAID 0 połączone są ze sobą przez RAID 1, dzięki czemu łączymy zalety obydwu sposobów. Macierz ta jest dwukrotnie szybsza i bezpieczna. Uszkodzenie jednego z dysków nie powoduje utraty danych, a cała macierz automatycznie przekształca się w RAID 0.
		\item \textbf{RAID 1+0.} Na pierwszy rzut oka ta macierz jest podobna do RAID 0+1 i rzeczywiście jest w tym sporo prawdy. Charakteryzuje sie również bezpieczeństwem danych i zwiększoną szybkością, ale trochę inną filozofią działania. Nawet gdy dwa dyski z różnych mirrorów (RAID 1) ulegną awarii, macierz nadal będzie działać.
		\item \textbf{RAID 2.} Poziom 2 jest rzadko stosowanym poziomem ochrony, w którym podziału danych dokonuje się już na poziomie bitów zapamiętanych z wykorzystaniem kodu Hamminga. Następnie zakodowane dane rozmieszczane są w sposób równomierny na wszystkich dyskach macierzy. W obecnych czasach poziom ten stracił na znaczeniu, ponieważ obecnie produkowane dyski wyposażone są w logikę ECC - Error Correction Code, co bezpośrednio prowadzi do stosowania ochrony z poziomu RAID 3. Inne funkcje poziomu 2 są identyczne jak w przypadku poziomu 3.
		\item \textbf{RAID 3.} Dane przechowywane są na n-1 dyskach, a jeden z dysków przechowuje tzw. sumy kontrolne obliczane przed dedykowany procesor. Dlatego do spięcia dysków w ten sposób wykorzystywana jest odrębna karta sprzętowa RAID, aby cała operacja nie obciążała procesora głównego komputera. Zasada działania tej konfiguracji przypomina RAID 0 z tą różnicą, że awarii może ulec jeden z dysków, którego dane zostaną odczytane z sum kontrolnych, kosztem szybkości.
		\item \textbf{RAID 4.} RAID 4 działa na podobnej zasadzie co RAID 3. Z tą różnicą, że dane są zapisywane na segmenty liczące 16, 32, 64, lub 128 kB. Ta metoda przydatna jest przy przechowywaniu plików o dużych rozmiarach.
		\item \textbf{RAID 5.} Bardzo popularna metoda łączenia dysków w macierze stosowana w środowiskach serwerowych. Do RAID 5 potrzebne są co najmniej 3 dyski twarde, na których zapisywane są dane wraz sumami kontrolnymi. Np. łącząc 3 dyski po 500GB otrzymamy pojemność 1000GB. Gdy uszkodzi się jeden z dysków, system nadal będzie działał.
		\item \textbf{RAID 6.} RAID 6 to rozbudowana wersja RAID 5, gdyż pojemność tej macierzy wynosi n-2 razy pojemność najmniejszego z dysków. Na dysku zapisywane są dwie sumy kontrolne, więc awarii mogą ulec aż dwa HDD bez uszczerbku w działaniu systemu.
	\end{itemize}

	\section{Zasada działania systemów klastrowych.}
	Klaster to grupa połączonych jednostek komputerowych, które współpracują ze sobą w celu udostępnienia zintegrowanego środowiska pracy. W istniejących rozwiązaniach klastrowych można wyodrębnić trzy podstawowe klasy wynikające z celów budowy takich rozwiązań:
	
	\begin{itemize}
		\item \textbf{klastry wydajnościowe}: pracujące jako zespół komputerów, z których każdy wykonuje własne zadania obliczeniowe. Celem ich budowy jest powiększenie mocy obliczeniowej, w sytuacji kiedy różne komputery w klastrze pracują nad odrębnymi podzadaniami pojedynczego dużego zadania obliczeniowego.
	
		\item \textbf{klastry niezawodnościowe}: pracujące jako zespół komputerów wykonujące każdy swoje zadanie. W razie awarii jednego z węzłów, następuje automatyczne przejęcie jego funkcji przez inne węzły.
		
		\item \textbf{klastry równoważenia obciążenia}: pracujące jako zespół komputerów, z których każdy wykonuje własne zadanie z puli zadań skierowanych do całego klastra. W takiej sytuacji pojedynczy komputer może wykonywać niezależne zadanie lub współpracować z kilkoma innymi węzłami klastra wykonując podzadanie większego zadania obliczeniowego.
	\end{itemize}
	
	W praktyce rozwiązania klastrowe mają charakter mieszany i wykonują dla pewnych aplikacji funkcje wydajnościowe, przy jednoczesnym odgrywaniu roli niezawodnościowej lub równoważenia obciążenia.

	\section{Zasada działania systemów ekspertowych.}
	Oparte o bazy wiedzy (zasady jeżeli-to); wspomagają podejmowanie decyzji. Mogą wspomagać interpretację danych oraz przeprowadzać prognozę i diagnozę na ich podstawie.
	Systemy ekspertowe rozwiązują złożone problemy na podstawie analizy baz wiedzy, a nie realizację prostego algorytmu.

	\section{Omów zasadę działania monitora (CRT lub LCD).}
	\label{sec:zasdziallcd}
	\textbf{LCD} - zbudowany z macierzy komórek zawierających ciekły kryształ o kolorowych filtrach. Elektrody wytwarzają pole elektryczne, które wywołuje zmianę cząsteczek ciekłego kryształu, co z kolei powoduje zmianę polaryzacji światła przez nie przechodzącego, a co za tym idzie, ilości przepuszczanego światła. Z tyłu ekranu montowane jest dodatkowe podświetlenie, które ten efekt podkreśla.

	\section{Wymienić i scharakteryzować rodzaje pamięci półprzewodnikowych}
	\begin{itemize}
		\item \textbf{Ulotne - Pamięci RAM} \textit{Random Access Memory} - Pamięć o dowolnym dostępie - posiada możliwość odczytu i zapisu. Zawartość takiej pamięci jest tracona po zaniku zasilania. 
		\begin{itemize}
			\item \textbf{Statyczne - SRAM} - zbudowane z przerzutników bistabilnych przechowujących bity informacji. Ze względu na wysoki koszt produkcji pamięci nie są wykorzystywane jako pamięć podstawowa komputerów. Ze względu na dużą szybkość działania znalazły one zastosowanie w układach buforujących - pamięć cache. 
			\item \textbf{Dynamiczne - DRAM} - zbudowane z macierzy kondensatorów przechowujących bity informacji w postaci ładunków elektrycznych. Znacznie tańsze od pamięci statycznych, ale również pamięć ta jest zbyt wolna do wielu zastosowań. Obecnie najszersze zastosowanie tej pamięci to pamięć podstawowa komputerów. 
		\end{itemize}
	\end{itemize}
		\begin{itemize}
		\item \textbf{Nieulotne - Pamięci ROM} \textit{Read Only Memory} - posiada jedynie możliwość odczytu, niektóre rodzaje posiadają możliwość zaprogramowania nowej zawartości przez użytkownika. Zawartość tej pamięci jest utrzymywana po wyłączeniu zasilania. 
		\begin{itemize}
			\item \textbf{ROM} - Pamięć tylko do odczytu. Informacja zawarta w tej pamięci jest zapisywana w czasie produkcji w formie maski na podstawie dostarczonego wzorca. Nie ma możliwości zmiany zawartości tej pamięci. Używana w urządzeniach produkowanych seryjnie. 
			\item \textbf{PROM} - Pamięć stała, obecnie rzadko używana. Programowanie odbywa się przez przepalanie wbudowanych przełączeń bezpieczników. Zawartość pamięci nie może być zmieniana. 
			\item \textbf{EPROM} - Pamięć stała, programowana elektrycznie. Użytkownik może sam zapisywać do niej informacje. Gdy układ posiada okienko ze szkła kwarcowego można pamięć kasować i programować ponownie. Kasowanie odbywa się przez naświetlanie ultrafioletem. Układy EPROM mogą być kasowane i ponownie programowane około 100 razy. 
			\item \textbf{EEPROM} - Pamięć stała, z możliwością elektrycznego zapisywania i kasowania. Ilość cykli kasowania i programowania jest ograniczona do około 10000. Płytka półprzewodnikowa pamięci EEPROM jest większa niż EPROM i przez to droższa. 
			\item \textbf{Flash-ROM} - Pamięć stała, obecnie coraz częściej używana ze względu na niski koszt produkcji i łatwość programowania. Do ponownego zaprogramowania tej pamięci nie są potrzebne specjalistyczne urządzenia, wystarczy odpowiednie oprogramowanie dla sprzętu, w którym kość została użyta.
		\end{itemize}
	\end{itemize}
	

	\section{Przedstaw tablice prawdy AND, OR, XOR, zilustruj oznaczenie bramki, wymień przykładowe zastosowanie.}
	\begin{figure}[h!]
		\begin{subfigure}[b]{.33\linewidth}
			\centering
			\begin{circuitikz}  
				\draw (0,0) node[and port] (and1) {};
			\end{circuitikz}
			\caption{AND}\label{fig2a}
		\end{subfigure}\hfill
		\begin{subfigure}[b]{.33\linewidth}
			\centering
			\begin{circuitikz}  
				\draw (0,0) node[or port] (or1) {};
			\end{circuitikz}
			\caption{OR}\label{fig2b}
		\end{subfigure}\hfill
		\begin{subfigure}[b]{.33\linewidth}
			\centering
			\begin{circuitikz}  
				\draw (0,0) node[xor port] (xor1) {};
			\end{circuitikz}
			\caption{XOR}\label{fig2c}
		\end{subfigure}%
	\end{figure}

	\begin{table}[!h]
		\centering
		\begin{subtable}{0.33\textwidth}
			\centering
			\begin{tabular}{ cc|c } 
				a & b & y \\ 
				\hline
				0 & 0 & 0 \\ 
				0 & 1 & 0 \\ 
				1 & 0 & 0 \\ 
				1 & 1 & 1 \\ 
			\end{tabular}
		\end{subtable}%  
		\begin{subtable}{0.33\textwidth}
			\centering
			\begin{tabular}{ cc|c } 
				a & b & y \\ 
				\hline
				0 & 0 & 0 \\ 
				0 & 1 & 1 \\ 
				1 & 0 & 1 \\ 
				1 & 1 & 1 \\ 
			\end{tabular}
		\end{subtable}%  
		\begin{subtable}{0.33\textwidth}
			\centering
			\begin{tabular}{ cc|c } 
				a & b & y \\ 
				\hline
				0 & 0 & 0 \\ 
				0 & 1 & 1 \\ 
				1 & 0 & 1 \\ 
				1 & 1 & 0 \\ 
			\end{tabular}
		\end{subtable}%  
	\end{table} 

	\section{Wątki a procesy - na podstawie wybranego systemu. Wymienić wady, zalety.}
	Wątki:
	\begin{itemize}
		\item jednostka wykonawcza w obrębie jednego procesu, będąca ciągiem instrukcji wykonywanym w obrębie tych samych danych
		\item jednostka podrzędna w stosunku do procesów – żaden wątek nie może istnieć bez procesu nadrzędnego, ale jeden proces może mieć więcej niż jeden wątek podporządkowany
		\item w systemach wieloprocesorowych, a także w systemach z wywłaszczaniem, wątki mogą być wykonywane współbieżnie.
		\item oddzielne liczniki rozkazów, rejestry, stos i wskaźnik stosu, stan
		\item wspólna przestrzeń adresowa, otwarte pliki, procesy potomne, obsługa sygnałów, zmienne globalne
		\item zalety
		\begin{itemize}
			\item utworzenie i zakończenie wątku zajmuje znacznie mniej czasu niż w przypadku procesu
			\item możliwość szybkiego przełączania kontekstu pomiędzy wątkami tego samego procesu
			\item możliwość komunikacji wątków bez pośrednictwa systemu operacyjnego
			\item możliwość wykorzystania maszyn wieloprocesorowych SMP
		\end{itemize}
		\item wady
		\begin{itemize}
			\item “Źle zachowujący się wątek” może zakłócić pracę innych wątków tego samego procesu.
		\end{itemize}
	\end{itemize}
	
	Procesy:
	\begin{itemize}
		\item program w trakcie wykonywania
		\item każdy proces posiada rodzica
		\item posiada własne zasoby (przestrzeń adresową, listę plików, przydzielone urządzenia)
	\end{itemize}

	\section{Budowa typowego układu FPGA.}
	Cechą charakterystyczną architektury FPGA jest duża liczba regularnie rozmieszczonych (w formie matrycy) konfigurowalnych komórek logicznych opartych na tablicach LUT (Look up Table), określanych generatorami funkcji. Układ FPGA zbudowany jest z programowalnych bloków logicznych oraz programowalnej macierzy połączeń. Bloki mogą być skomplikowanymi układami lub pojedynczymi bramkami logicznymi. Bloki zawierają również elementy pamięciowe (np. przerzutniki).

	\section{Podstawowe tryby adresowania systemów mikroprocesorowych.}
	\begin{itemize}
		\item \textbf{natychmiastowy (immediate)} - pole adresowe zawiera bezpośrednio operand czyli daną dla rozkazu. Ten tryb adresowania stosujemy, gdy np. chcemy bezpośrednio z rozkazu (bez odwoływania się do pamięci) załadować do rejestru prostą daną - bajt lub parę bajtów.
		\item \textbf{bezpośredni (direct)} - zawartość pola adresowego stanowi już finalny adres argumentu rozkazu w pamięci operacyjnej i nie podlega przekształceniu. Stosowany, gdy nie zależy nam na tym, aby program był przesuwalny w pamięci operacyjnej, lecz jest przeznaczony do wykonania przy zapisie w ściśle określone miejsce w pamięci.
		\item \textbf{pośredni (indirect)} - rozkaz zawiera adres komórki pamięci operacyjnej, w której zawarty jest finalny adres operandu rozkazu. W tym przypadku komórka pamięci wskazana przez adres rozkazu pośredniczy w określeniu finalnego adresu. Stosujemy, aby finalny adres operandu rozkazu mógł być dynamicznie wstawiony do komórki pośredniczącej w adresowaniu w czasie wykonywania programu.
		\item \textbf{rejestrowy (register)} - stosuje się, gdy dana dla rozkazu jest przechowywana w rejestrze. Część adresowa rejestru zawiera wtedy jedno lub więcej pól, w których znajdują się identyfikatory rejestrów. Adresowanie rejestrowe jest często stosowane w tym samym rozkazie razem z innymi trybami adresowania dotyczącymi pamięci operacyjnej. Wówczas rozkaz dotyczy zarówno pamięci operacyjnej jak i rejestrów procesora.
		\item \textbf{rejestrowy pośredni (register indirect)} - jako miejsce pobrania finalnego adresu operandu rozkazu stosuje się rejestr procesora, którego identyfikator umieszczony jest w polu adresowym rozkazu. Przy pomocy tego trybu adresowania można dynamicznie określić finalny adres operandu poprzez odpowiednie załadowanie zawartości rejestru, w zależności od przebiegu obliczeń w programie.
		\item \textbf{z przesunieciem (indeksowanie) (displacement (indexed))} - wykorzystuje się specjalne rejestry procesora, które zawierają przesunięcie, które trzeba dodać do adresu istniejącego w rozkazie, aby wyliczyć adres finalny operandu. Używając tego trybu we wszystkich rozkazach programu, można osiągnąć możliwość wykonania programu przy załadowaniu w dowolne miejsce pamięci. W tym celu należy napisać program wstawiając do rozkazów programu adresy, które odpowiadają umieszczeniu pierwszej instrukcji programu pod adresem zerowym w pamięci. Wiedząc, pod jakim adresem jest umieszczony pierwszy rozkaz programu, umieszczamy ten adres w rejestrze indeksowym. Dzięki operacji temu, wszystkie adresy operandów zostaną przesunięte o tę sama wartość.
	\end{itemize}

	\section{Hierarchia pamięci w systemie komputerowym, stronicowanie oraz koncepcja pamięci wirtualnej.}
	\begin{itemize}
		\item Rejestry wewnętrzne procesora
		\item Pamięć podręczna „cache”
		\item Pamięć operacyjna
		\item Pamięć wirtualna (dyski twarde)
	\end{itemize}

	\textbf{Stronicowanie} to metoda implementacji pamięci wirtualnej. Pamięć fizyczna dzielona jest na bloki (strony) o równych wielkościach. Adresy logiczne następnie mapowane są na odpowiednie strony oraz fizyczne adresy.
	
	\textbf{Pamięć wirtualna} pozwala na traktowanie pamięci komputera w jednolity sposób. Jeżeli program wymaga większej pamięci niż tej dostępnej, system operacyjny może wykorzystać pamięć dyskową, jednak postępowanie pozostaje bez zmian.

	\section{Omówić strukturę i funkcjonowanie systemu transmisyjnego.}
	\begin{enumerate}
		\item źródło wiadomości - generuje wiadomości
		\item A/C - przetwornik analogowo-cyfrowy
		\item koder źródła - kompresowanie danych
		\item koder kanału - wysyła dodatkowe dane do sprawdzania i korekcji błędów
		\item modulator - umieszczenie sygnału w odpowiednim paśmie częstotliwości i właściwe ukształtowanie jego widma
		\item układ wysokiej częstotliwości - wzmacnia sygnał analogowy do wymaganego poziomu
		\item \textit{fale w eterze}
		\item układ wysokiej częstotliwości
		\item demodulator
		\item dekoder kanału - decyduje o poprawności przesyłanych danych i tworzy sekwencję kodową wysłanego sygnału
		\item dekoder źródła - przetwarza informację binarną na pierwotnie wysłaną
		\item \textit{C/A}
		\item odbiorca wiadomości
	\end{enumerate}

	\section{Różnice między pamięcią statyczną i dynamiczną.}
	\label{sec:statdyn}
	\begin{itemize}
		\item \textbf{SRAM} - bez zegara, bez konieczności odświeżania, niskie zużycie mocy, każda komórka składa się z 6 tranzystorów -- pamięć szybka, wysoka cena, wykorzystywana w małych ilościach (cache procesora). 
		\item \textbf{DRAM} -  wymagane cykliczne odświeżanie, każda komórka składa się z 1 tranzystora -- pamięć wolniejsza, niska cena (pamięć RAM).
	\end{itemize}

	\section{Problem synchronizacji przy transmisji danych i transmisja asynchroniczna}
	Synchroniczna i asynchroniczna metoda transmisji danych określają w jaki sposób dwie przeciwległe stacje, rozwiązują kwestię sygnalizacji nadawania danych. Bez takiej sygnalizacji, stacja odbiorcza nie byłaby w stanie odgadnąć, czy dane które akurat dotarły, to początek, koniec, czy środek transmisji.

	W transmisji asynchronicznej problem sygnalizacji początku i końca nadawania został rozwiązany dzięki temu, że została zawarta w przesyłanych danych. Czyli, to sama struktura porcji danych określa jej początek i koniec.
	W transmisji synchronicznej sygnalizacja początku i końca została rozwiązana za pomocą odrębnego kanału sygnalizującego/serwisowego. Kanał ten dyktuje takt, według którego są przesyłane dane. Natomiast dane są zwykle przesyłane odrębnymi kanałami.

	\section{Uprawnienia plików na przykładzie systemu operacyjnego Unix/Linux.}
	Nadawanie praw odbywa się poprzez komendę \textit{chmod}. Uprawnienia plików dotyczą trzech grup:
	\begin{itemize}
		\item właściciela pliku,
		\item grupy, do której należy właściciel,
		\item pozostałych, niespełniających poprzednich warunków.
	\end{itemize}
	
	Uprawnienia dotyczą:
	\begin{itemize}
		\item odczytu,
		\item zapisu,
		\item wykonania plików
	\end{itemize}

	\section{Scharakteryzować sieciowe systemy plików.}
	p. \ref{sec:siecsysplik}

	\section{Co to jest cykl życia oprogramowania i z jakich faz się składa?}
	Ciąg działań projektowo-programowych, obejmujący zakres od powstania zapotrzebowania na oprogramowanie aż do jego wycofania z eksploatacji. Podstawowe czynności związane z tworzeniem oprogramowania:
	\begin{itemize}
		\item Określanie wymagań i specyfikacji
		\item Projektowanie
		\item Implementacja
		\item Testowanie – walidacja (atestowanie) i weryfikacja
		\item Konserwacja (pielęgnacja)
	\end{itemize}

	\section{Wymienić rodzaje diagramów w UML}
	\begin{itemize}
		\item diagram klas - przedstawia strukturę aplikacji
		\item diagram przypadków użycia - przedstawia funkcjonalność systemu wraz z jego otoczeniem, służy do zobrazowania usług, które są widoczne z zewnątrz systemu
		\item diagram sekwencji - prezentowanie interakcji pomiędzy obiektami wraz z uwzględnieniem w czasie komunikatów
		\item diagram aktywności - przedstawienie sekwencji kroków, które są wykonywane przez modelowany fragment systemu
		\item diagram komponentów - służy do ilustracji organizacji i zależności pomiędzy komponentami; prezentuje system na wyższym poziomie abstrakcji niż diagram klas, gdyż każdy z komponentów może być implementacją jednej lub większej liczby klas
	\end{itemize}

	\section{Co oznaczają skróty ERD oraz DFD? Do czego się ich używa?}
	\begin{itemize}
		\item \textbf{ERD} - Entity-Relationship Diagram - rodzaj graficznego przedstawienia związków pomiędzy encjami używany w projektowaniu systemów informacyjnych (np. beaz danych) do zademonstrowania konceptualnych modeli danych używanych w systemie.
		\item \textbf{DFD} - Data Flow Diagram - Przedstawia on, w jaki sposób dane przepływają w systemie oraz opisuje procesy przetwarzające dane. Tworzenie diagramu DFD opiera się na następujących kategoriach pojęciowych: proces, przepływ danych, magazyn danych, terminator.
	\end{itemize}

	\section{Przeciążanie funkcji i operatorów w języku C++.}
	\label{sec:przecfuncpp}
	Przeciążanie funkcji polega na definicji funkcji o takiej samej nazwie co już istniejąca, o innych parametrach wejściowych lub wyjściowych (ale nie wyłącznie wyjściem). Przy wywołaniu funkcji, wybierana jest ta, o odpowiedniej liczbie i typach argumentów.
	Przeciążanie operatorów polega na określeniu funkcji o specjalnej nazwie operator @ dla pewnego operatora @ i typu lub typów. Niektórych operatorów nie można przeciążać, należą do nich m.in. operator ':?' oraz '.'.

	\section{Scharakteryzować instrukcje iteracyjne w przykładowym języku programowania}
	Język C:
	\begin{itemize}
		\item \textbf{for (wyrażenie początkowe; wyrażenie logiczne; wyrażenie wykonywane co iterację) \{ ciało pętli \}}\\
		pętla wykonuje się do momentu, gdy wyrażenie logiczne zwróci fałsz (wartość 0).
	
		\item \textbf{while (wyrażenie logiczne) \{ ciało pętli \}}\\	
		pętla wykonuje się dopóki wyrażenie logiczne zwraca prawdę (wartość różną od 0).
		
		\item \textbf{do \{ ciało pętli \} while (wyrażenie logiczne);}\\
		pętla wykona się co najmniej raz, warunek sprawdzany jest pod koniec pętli. Jeżeli ciało pętli zawierają tylko jedno wyrażenie, nawiasy klamrowe mogą zostać opuszczone.
	\end{itemize}

	\section{Omówić na czym polega przeciążanie funkcji i operatorów w języku C++.}
	p. \ref{sec:przecfuncpp}

	\section{Scharakteryzować mechanizmy dostępu do składowych klasy tworzonych statycznie i dynamicznie}
	Zakładając język C++, do składowych statycznych odwołanie następuje wg schematu nazwa-klasy::nazwa-składowej lub nazwa-obiektu.nazwa-składowej lub nazwa-wskaźnika->nazwa-składowej. Dla składowych klasy tworzonych dynamicznie tak jak wyżej z pominięciem przypadku z operatorem ::.

	\section{Omów pojęcia agregacji i zawierania w diagramach UML.}
	(Visual Paradigm) W diagramach klas \textbf{agregacja} nie oznacza, że klasa dziedziczy z innej klasy. Oznacza tylko, że obiekt klasy A zawiera obiekt klasy B, np auto 	posiada silnik, jednak bez auta, silnik też może istnieć.\\
(Wykłady) W diagramach przypadków użycia zależność \textbf{zawierania} include umożliwia odwzorowanie sytuacji gry wraz z zawierającym przypadkiem użycia (bazowym) wykonywany jest przypadek zawierany. Związek jest związkiem obligatoryjnym - przypadek jest zawsze wykonywany.\\
(Wykłady) W diagramach przypadków użycia - uogólnienia umożliwiają \textbf{agregację} wielu przypadków/aktorów specjalizowanych do jednego przypadku/aktora ogólnego.

	\section{Budowa i zasady działania wybranego urządzenia (drukarka laserowa, dysk twardy, pamięć USB, streamer, ect.)}
	p. \ref{sec:zasdziallcd}

	\section{Metody komunikacji człowiek-komputer.}
	\begin{itemize}
		\item język poleceń
		\item formularze
		\item menu
		\item manipulacja bezpośrednia
		\item komunikacja w języku naturalnym
		\item interfejsy multimedialne
		\item sprzęgi rzeczywistości wirtualnej
	\end{itemize}

	\section{Wymienić metody ekstrakcji wiedzy z danych.}
	\begin{itemize}
		\item streszczanie
		\item poszukiwanie asocjacji
		\item analiza jakościowa danych
		\item analiza ilościowa danych
		\item klasyfikacja
		\item grupowanie
	\end{itemize}

	\section{Co to są drzewa decyzyjne i do czego służą?}
	Jest to graficzna metoda wspomagania procesu decyzyjnego zawierającego decyzje i ich możliwe konsekwencje. Proces decyzyjny jest przedstawiony za pomocą grafu (drzewa), gdzie wierzchołki określają aktualny stan a krawędzie pewne decyzje.

	\section{Rekurencja i jej implementacja w językach wysokiego poziomu}
	Rekurencja jest to sytuacja, w której funkcja wywołuje samą siebie w celu rozwiązania pewnego problemu. Każda funkcja rekurencyjna musi posiadać warunek zatrzymania (warunek stopu) – stan danych, dla którego nie dojdzie do ponownego wywołania funkcji. W przeciwnym razie będzie się wywoływała do momentu przepełnienia stosu.

	\section{Co to są algorytmy zachłanne – podać przykład takiego algorytmu.}
	Algorytmy podejmujące w każdym kroku taką decyzję, która w danej chwili wydaje się najkorzystniejsza. Dokonują zawsze wyborów lokalnie optymalnych licząc, że doprowadzi to do znalezienia rozwiązania globalnie optymalnego. Przykład: ciągły problem plecakowy (znajduje rozwiązanie optymalne), dyskretny problem plecakowy (nie gwarantuje optymalnego rozwiązania).

	\section{Na czym polega haszowanie i gdzie ma ono zastosowanie?}
	Haszowanie jest metodą szybkiego wyszukiwania danych w tablicach. Polega to na tym, iż mamy tzw. funkcję haszującą, która dla danego zestawu danych tworzy liczbę zwaną haszem. Liczbę tą używamy jako indeks w tablicy haszowanej do dostępu do danych. Podstawowym problemem haszowania jest kolizyjność. Polega ona na tym, iż funkcja haszująca tworzy te same wartości dla wielu różnych danych. Takie ograniczenie jest konieczne, ponieważ w przypadku przeciwnym hasz przyjmowałby wartości z bardzo dużego zakresu, a to z kolei przekładałoby się na tablicę o bardzo dużym rozmiarze, zwykle większym, niż może pomieścić pamięć komputera.

	\section{Co to są problemy obliczeniowo trudne – podać przykład takiego problemu.}
	Problemami klasy NP nazywamy problemy decyzyjne w których sprawdzenie poprawności określonego rozwiązania wymaga złożoności obliczeniowej wielomianowej. Z powyższego stwierdzenia wynika więc, że znalezienie rozwiązania dla problemów NP wymaga złożoności co najmniej wielomianowej. Np. problem komiwojażera, plecakowy.

	\section{Maszynowa reprezentacja danych}
	Ciąg bitów, często o rozmiarze $2^n$ bitów. Może reprezentować liczby całkowite bez znaku (bezpośrednia reprezentacja, kod BCD lub kod Graya), liczby całkowite ze znakiem (np. kod uzupełnień do 2 U2), liczby stałoprzecinkowe (np. bezpośrednia reprezentacja, z separatorem ustalonym na danej pozycji), liczby zmiennoprzecinkowe (np. standard IEEE 754 -- bit znaku, bity cechy i mantysy), znaki (7-bitowa reprezentacja ASCII lub inne kodowanie, np. UTF-8 mapowane na znaki Unicode).

	\section{Assembler, interpreter, kompilator – porównać i wyjaśnić pojęcia.}
	\begin{itemize}	
		\item \textbf{assembler}: program zamieniający kod w języku assembly na kod maszynowy,
		\item \textbf{interpreter}: program interpretujący kod pewnego języka programowania w trakcie jego wykonywania,
		\item \textbf{kompilator}: program zamieniający kod pewnego języka programowania na postać pośrednią (np. bytecode) lub kod maszynowy przed jego wykonaniem.
	\end{itemize}	

	\section{Zarządzanie pamięcią w Unix/Linux.}
	Podsystem zarządzania pamięcią zapewnia:
	\begin{itemize}
		\item 	dużą przestrzeń adresową: wykorzystując pamięć wirtualną, system operacyjny sprawia wrażenie posiadania znacznie większej ilości pamięci,
		\item ochronę pamięci (segmentacja): każdy proces ma do dyspozycji własną wirtualną przestrzeń adresową. Przestrzenie te są odseparowane i jedna aplikacja nie może wpłynąć na inną. Pamięć może także być oznaczona jako chroniona przed zapisem.
		\item mapowanie pamięci: zawartość pliku może być bezpośrednio włączona w przestrzeń adresową procesu
		\item alokację pamięci fizycznej: każdy może posiadać dostateczny kawałek pamięci fizycznej
		\item dzieloną pamięć wirtualną: możliwość dzielenia pamięci pomiędzy procesami.
		\item stronicowanie: podział pamięci na bloki ustalonego rozmiaru oraz odwoływanie się do nich nie bezpośrednio, lecz poprzez tablice mapujące
	\end{itemize}

	\section{Zasady korzystanie z kluczy i pakietów kryptograficznych PGP (Pretty Good Privacy)}
	Program PGP może generować klucze asymetryczne -- generowana jest para kluczy. Jeden z nich stosowany jest do szyfrowania i autoryzacji (publiczny), drugi do podpisywania i deszyfrowania wiadomości (prywatny). PGP jest stosowany do podpisywania, szyfrowania i deszyfrowania wiadomości oraz całych partycji dyskowych. Poszczególne podmioty podpisują sobie nawzajem klucze, przez co progresywnie formuje się sieć indywidualnych kluczy publicznych połączonych ze sobą łączami stworzonymi przez podpisy (Web of Trust).

	\section{Metody reprezentacji wiedzy i wnioskowanie.}
	\begin{itemize}
		\item Rachunek zdań i predykatów -  systemem wyrażeń będących formułami prawdziwymi, w którym nie stosuje się konkretnych zdań, lecz posługuje się tzw. zmiennymi zdaniowymi reprezentującymi zdania. Cała teoria opiera się na klasycznej logice dwuwartościowej.
		
		\item Zapis stwierdzeń - dotyczą takich zagadnień jak zdarzenia, zjawiska, objawy, czynności. (OBIEKT, ATRYBUT, WARTOŚĆ).
		
		\item Systemy regułowe - ogólna postać: IF przesłanka THEN konkluzja1 ELSE konkluzja2.
		
		\item Sieci semantyczne - sieć stwiedzeń, gdzie węzły odpowiadają kompletnym opisom pojęć lub obiektów. Relacje między obiektami przedstawione są w postaci rysunku.
		
		\item Oparte na ramach - grupowanie informacji dotyczących wybranego fragmentu wiedzy w postaci jednej ramy, co uprascza późniejszą weryfikację.
		
		\item Używające modeli obliczeniowych - rozwięzywanie prostych problemów z dziedzin elementarnych. Składają się ze zmiennych i zbioru relacji wiążących te zmienne.
	\end{itemize}

	\textbf{Wnioskowanie} to proces myślowy, w którym na podstawie zdań już uznanych za prawdziwe (przesłanek) dochodzi się się do nowego dotąd nie uznanego zdania (wniosku), bądź wzmacnia się pewność innego zdania w jakimś stopniu już uznanego.


	\section{Zasady przetwarzanie transakcji w DBMS.}
	ACID:
	\begin{itemize}
		\item \textbf{Atomicity}: atomowość, transakcja odbywa się w całości albo w ogóle,
		\item \textbf{Consistency}: spójność, transakcje nie naruszają integralności danych,
		\item \textbf{Isolation}: transakcje odbywają się bez wiedzy o innych,
		\item \textbf{Durability}: trwałość, wyniki zatwierdzonych transakcji nie mogą zostać utracone.
	\end{itemize}

	\section{Narzędzia i środowiska wytwarzania oprogramowania.}
	Eclipse, Visual Studio, Qt Creator, Git, SVN, GDB, Gerrit, Jenkins \dots

	\section{Wzorce projektowe i programowe.}
	Określają pewne schematy postępowania przy projektowaniu systemów bazowanych na obiektach. Podział na wzorce
	\begin{itemize}
		\item kreacyjne
			\begin{itemize}
				\item opisujące proces tworzenia nowych obiektów; ich zadaniem jest tworzenie, inicjalizacja oraz konfiguracja obiektów, klas oraz innych typów danych
				\item np. budowniczy, fabryka abstrakcyjna, prototyp, singleton
			\end{itemize}
		\item strukturalne
		\begin{itemize}
			\item opisujące struktury powiązanych ze sobą obiektów
			\item np. adapter, dekorator, most
		\end{itemize}
		\item czynnościowe
		\begin{itemize}
			\item opisujące zachowanie i odpowiedzialność współpracujących ze sobą obiektów
			\item np. iterator, obserwator, strategia
		\end{itemize}
	\end{itemize}

	\section{Metody podnoszenia niezawodności systemów wbudowanych.}
	Testowanie, ograniczenie złożoności zadań, rozdzielanie zadań na mniejsze systemy, redundancja (jedno urządzenie przejmuje zadania drugiego w przypadku jego awarii). Stosowanie urządzeń typu \textit{watchdog} - wykrywający błędne działanie systemu, próbujący je naprawić bez udziału człowieka i zapobiec poważniejszej awarii.

	\section{Ryzyko i odpowiedzialność związana z systemami informatycznymi}
	Ryzyko to miara zagrożenia wynikającego z prawdopodobieństwa wystąpienia pewnych niekorzystnych zdarzeń. Za ocenę ryzyka i identyfikację zagrożeń dla projektu odpowiedzialny jest menedżer projektu.

	\section{Klasyfikacja systemów oprogramowania użytkowego.}
	\begin{itemize}
		\item akcesoria (słowniki, kompresory),
		\item bezpieczeństwo (antywirusy),
		\item biuro (edytory),
		\item grafika (edytory),
		\item internet (przeglądarki),
		\item multimedia (odtwarzacze).
	\end{itemize}

	\section{Systemy wspomagające wytwarzanie oprogramowania – klasyfikacja, przykłady, funkcje.}
	Systemy CASE (\textit{Computer Aided Software Engineering}). Klasyfikacja:
	\begin{itemize}
		\item narzędzia wspierające poszczególne zadania w cyklu życia oprogramowania, w tym
		\begin{itemize}
			\item Upper CASE: modelowanie logiki biznesowej, analiza,
			\item Lower CASE: testowanie, integracja komponentów,
		\end{itemize}
		\item narzędzia wspierające dwa lub więcej zadań w cyklu życia oprogramowania,
		\item środowiska wspierające cały cykl życia oprogramowania.
	\end{itemize}
	
	Przykłady:
	\begin{itemize}
		\item Enterprise Architect
		\item Visual Paradigm
		\item Oracle Designer
		\item Rose
	\end{itemize}

	Funkcje:
	\begin{itemize}
		\item modelowanie logiki biznesowej (graficzne narzędzia),
		\item projektowanie i konstrukcja,
		\item weryfikacja i walidacja,
		\item metryka i miara (np. postępu),
		\item zarządzanie projektem.
	\end{itemize}


	\section{Wymienić i scharakteryzować podstawowe techniki w grafice komputerowej.}
	\begin{itemize}
		\item antyaliasing - wygładza krawędzie aby nie były poszarpane,
		\item oświetlenie - sposób obliczania rozchodzenia się światła w danym otoczeniu prowadzący do wyznaczenia kolorów powierzchni, 
		\item cieniowanie - sposób obliczania barwy pikseli należących do zrasteryzowanego wielokąta,
		\item raytracing - technika generowania fotorealistycznych obrazów scen trójwymiarowych opierająca się na analizowaniu tylko tych promieni światła, które trafiają bezpośrednio do obserwatora, 
		\item teksturowanie - przedstawienie szczegółów powierzchni obiektów przestrzennych za pomocą obrazów bitmapowych (tekstur) lub funkcji matematycznych (tekstur proceduralnych),
		\item filtracja tekstur - stosowanie mipmap, czyli tych samych tekstur, ale generowanych w niższej rozdzielczości,
		\item postprocessing - efekty nakładane na obraz już po wyrenderowaniu klatki.
	\end{itemize}

	\section{Wymienić i scharakteryzować metody przetwarzania obrazów.}
	\begin{itemize}
		\item operacje na histogramie - rozciąganie, wyrównywanie, 
		\item operacje geometryczne - w których położenie piksela (i, j) zmieniane jest zgodnie z zadaną relacją matematyczną, a jego intensywność nie ulega zmianie, (translacja, przeskalowanie, obroty, pochylenie)
		\item operacje arytmetyczne/logiczne - w których nowa wartość intensywności piksela obliczana jest na podstawie jego poprzedniej wartości zgodnie z przyjętą relacją arytmetyczną., natomiast położenie geometryczne piksela nie ulega zmianie (podnoszenie do kwadratu - polepszenie kontrastu, dodawanie, mnożenie, ...)
		\item normalizacja - sprowadzenie wartości obrazu do określonego przedziału wartości dozwolonych. Np. 8-bitową reprezentacje obrazu do przedziału liczb całkowitych z zakresu 0-255.
		\item filtracja - stosowana jest przeważnie jako metoda wydobycia z oryginalnego obrazu szeregu informacji w celu ich dalszej obróbki. Informacjami takimi mogą być: położenie krawędzi, pozycje rogów obiektów, itp. 
		\item wektoryzacja -  rastry opisujące daną bitmapę zostają zgrupowane w większe obiekty wektorowe na zasadzie podobieństwa koloru
		\item rasteryzacja - jak najwierniejsze przedstawienie płaskiej figury geometrycznej na urządzeniu rastrowym, dysponującym skończoną rozdzielczością.
		\item transformacja (na przykład Fouriera) - w celu kompresji, uwidocznienia cech niewidocznych w dziedzinie przestrzennej, projektowanie filtrów
	\end{itemize}

	\section{Zasady i metody tworzenia indeksów w bazach danych?}
	Warto indeksować:
	\begin{itemize}
		\item klucze podstawowe i obce (często są indeksowane automatycznie)
		\item pola, po których często następuje wyszukiwanie
		\item pola, do których dostęp następuje w ustalonej, uporządkowanej kolejności
	\end{itemize}
	Nie należy indeksować:
	\begin{itemize}
		\item pól, do których rzadko odwołują się zapytania
		\item pól, które zawierają tylko kilka wartości unikatowych
		\item pól zawierających dane typu image, bit czy obiekt OLE 
	\end{itemize}

	Podział (metody tworzenia?) indeksów:
	\begin{itemize}
		\item Indeks gęsty (dense) – zawiera wpis dla każdej wartości klucza wyszukiwania, czyli dla każdego rekordu.
		\item Indeks rzadki (sparse) – posiada wpis jedynie dla niektórych wartości wyszukiwania (np. bloków).
		\item Indeks podstawowy (primary index) – założony na atrybucie porządkującym unikalnym
		\item Indeks zgrupowany (clustering index) – założony na atrybucie porządkującym nieunikalnym
		\item Indeks wtórny (secondary index) – założony na atrybucie nieporządkującym
		\item Indeksy jednopoziomowe – jeden plik indeksu dla jednego pliku danych
		\item Indeksy wielopoziomowe – indeks do indeksu
	\end{itemize}

	\section{Rodzaje i sposób działania przerzutników.}
	\begin{itemize}
		\item  \textbf{RS} - Podstawowa wersja tego przerzutnika zawiera dwa wejścia: S i R. Wejście S (ang. SET - ustawić) powoduje ustawienie na wyjściu przerzutnika Q poziomu H (ang. HIGH - wysoki). Wejście R (ang. RESET - kasuj) służy do ustawiania na wyjściu sygnału L (ang. LOW - niski).  Są jego dwie wersje: asynchroniczna i synchroniczna (z wejściem zegarowym).
		
		\item  \textbf{D} - Przerzutnik D jest przerzutnikiem synchronicznym o jednym wejściu informacyjnym, oznaczonym literą D. Spełnia on funkcję przepisywania informacji z wejścia D na wyjście Q z opóźnieniem jednego impulsu taktującego, stąd też pochodzi jego nazwa Przerzutnik D od słowa angielskiego Delay (pol. opóźniający). Podstawowy przerzutnik RS może być wykorzystany jako podstawowa komórka pamięci. Wadą tego układu jest konieczność używania dwóch sygnałów wejściowych w celu wpisania do układu zera lub jedynki. 
		
		\item \textbf{T} - Synchroniczny przerzutnik typu T (ang. TOGGLE) ma dwa wejścia: zegarowe C i przełączające T. Przy każdym dodatnim zboczu sygnału zegarowego C (przejście ze stanu 0 do stanu 1) zmienia stany swoich wyjść na przeciwne. Przerzutnik typu T można skonstruować używając przerzutnik typu RS. Zmiana stanu przerzutnika odbywa się w momencie, kiedy sygnał zegara zmienia wartość z wysokiej na niską. Mówimy wówczas, że przerzutnik jest wyzwalany opadającym zboczem zegara.
		
		\item  \textbf{JK} - Podanie jedynki logicznej na wejście J powoduje ustawienie przerzutnika (co skutkuje pojawieniem się stanu wysokiego na wyjściu Q). Ustawienie wejścia K w stan wysoki przestawia przerzutnik w stan niski. Jeżeli jedynka logiczna zostanie ustawiona na obydwu wejściach (J i K) to nastąpi zmiana stanu przerzutnika na przeciwny.
		JK jest przerzutnikiem synchronicznym, co oznacza, że reaguje na stan wejść tylko przy podaniu odpowiedniego sygnału na wejście zegarowe. Wyjątkiem są wejścia asynchroniczne R i S. Podanie stanu wysokiego na wejście Set powoduje ustawienie w stan wysoki przerzutnika niezależnie od tego, czy został dostarczony sygnał zegarowy. Wejście Reset w analogiczny sposób zeruje przerzutnik.
	\end{itemize}

	\begin{table}[!h]
		\centering
		\begin{tabular}{|c|c|c|c|c|}
			\hline
			\textbf{S} & \textbf{R} & \textbf{Q(t)} & \textbf{Q(t+1)} & \textbf{Opis}   \\ \hline
			0          & 0          & 0 lub 1       & Q(t)            & Bez zmian       \\ \hline
			0          & 1          & 0 lub 1       & 0               & Zerowanie       \\ \hline
			1          & 0          & 0 lub 1       & 1               & Ustawianie      \\ \hline
			1          & 1          & 0 lub 1       & ?               & Stan zabroniony \\ \hline
		\end{tabular}
		\caption{Tablica charakterystyczna dla przerzutnika RS}
	\end{table}

	\begin{table}[!h]
		\centering
		\begin{tabular}{|c|c|c|c|}
			\hline
			\textbf{D} & \textbf{Q(t)} & \textbf{Q(t+1)} & \textbf{Operacja} \\ \hline
			0          & 0 lub 1       & 0               & Zerowanie         \\ \hline
			1          & 0 lub 1       & 1               & Ustawianie        \\ \hline
		\end{tabular}
		\caption{Tablica charakterystyczna dla przerzutnika D}
	\end{table}

	\begin{table}[!h]
		\centering
		\begin{tabular}{|c|c|}
			\hline
			\textbf{$Q_{n-1} \rightarrow Q_n$} & \textbf{T} \\ \hline
			$0 \rightarrow 0$	& 0           \\ \hline
			$0 \rightarrow 1$	& 1           \\ \hline
			$1 \rightarrow 0$	& 1           \\ \hline
			$1 \rightarrow 1$	& 0           \\ \hline
			\multicolumn{2}{|c|}{Przy C: $0 \rightarrow 1$}            \\ \hline
		\end{tabular}
		\caption{Tablica wzbudzeń dla przerzutnika T}
	\end{table}

	\begin{table}[!h]
		\centering
		\begin{tabular}{|c|c|c|c|c|}
			\hline
			\textbf{J} & \textbf{K} & \textbf{Q(t)} & \textbf{Q(t+1)} & \textbf{Opis}  \\ \hline
			0          & 0          & 0 lub 1       & 0 lub 1         & Podtrzymanie   \\ \hline
			0          & 1          & 0 lub 1       & 0               & Przejście na 0 \\ \hline
			1          & 0          & 0 lub 1       & 1               & Przejście na 1 \\ \hline
			1          & 1          & 0 lub 1       & 1 lub 0         & $\sim$Q        \\ \hline
		\end{tabular}
		\caption{Tablica wzbudzeń dla przerzutnika JK}
	\end{table}

	\section{Różnica pomiędzy automatem Mealy'ego a automatem Moore'a.}
	Wyjścia w automacie Mealy'ego zależą od stanu wewnętrznego i sygnałów wejściowych, w automacie Moore'a wyjścia zależą wyłącznie od stanu wewnętrznego. Automaty te są równoważne - jeden można zamienić bezstratnie w drugi.

	\section{Różnica pomiędzy układami typu PLA a układami PAL.}
	\textbf{PLA (Programmable Logic Array)}:
	\begin{itemize}
		\item programowalna matryca AND i OR
		\item wejścia i wyjścia są jednokierunkowe
		\item możliwe współdzielenie termów przez funkcje wyjściowe
	\end{itemize}
	
\textbf{PAL (Programmable Array Logic)}:
	\begin{itemize}
		\item programowalna matryca AND, matryca OR stała
		\item dwukierunkowe wejścia i wyjścia
		\item brak współdzielenia termów przez funkcje wyjściowe
		\item szybsze i o mniejszym poborze mocy
	\end{itemize}

	\section{Wymienić i omówić znanych światowych wynalazców w dziedzinie informatyki i telekomunikacji}
	\begin{itemize}
		\item \textbf{Michael Faraday} - wprowadził do fizyki pojęcia takie jak: linie siły pola magnetycznego i elektrycznego. Odkrył, że płaszczyzna polaryzacji światła ulega zmianie po przejściu przez pole magnetyczne (wskazuje to na związek m-dzy światłem a elektromagnetyzmem).
	
		\item \textbf{James Clerk Maxwell} - na podstawie rozważań teoretycznych wyciągnął wniosek, że światło jest falą elektromagnetyczną.
		
		\item \textbf{Thomas Alva Edison} - wynalazca, stworzył m.in. żarówkę, fonograf, akumulator. Udoskonalił telefon Alexandra Bella.
		
		\item \textbf{Heinrich Rudolf Hertz} - na podstawie teorii Maxwella przeprowadził eksperyment potwierdzający jego teoretyczne rozważania. Pionier radiokomunikacji.
		
		\item \textbf{Samuel Morse} - malarz i wynalazca, skonstruował telegraf elektromagnetyczny i opracował dla niego specjalny alfabet złożony z kombinacji kresek i kropek.
		
		\item \textbf{Alexandr Stiepanowicz Popow} - na podstawie badań H. Hertza stworzył radiotelegraf.
		
		\item \textbf{Nikola Tesla} - stworzył podstawy teoretyczne konstrukcji radia, był m.in twórcą pierwszych urządzeń bezprzewodowych.
		
		\item \textbf{Alexander Graham Bell} - wynalazca, opracował telefon. Podstawowe dzieło to praca dotycząca sposobu zapisywania i odtwarzania mowy.
		
		\item \textbf{Jean Baudot} - skonstruował aparat telegraficzny bodot. Od jego nazwiska pochodzi jednostka szybkości modulacji bod.
		
		\item \textbf{Agner Krarup Erlang} - opracował wzór (znany dziś jako wzór Erlanga) do obliczenia natężenia ruchu sieci telefonicznej. Pierwsza osoba, która zajęła się problemem sieci telefonicznych.
	\end{itemize}

	\section{Omówić sposoby prezentacji informacji oraz pojęcia informacji analogowej i cyfrowej, sygnału analogowego oraz cyfrowego.}
	\textbf{Informacja}:
	\begin{itemize}
		\item Analogowa - informacje w tej postaci mogą być:
		\begin{itemize}
			\item Prosta - mocno wyróżniona jedna częstotliwość i niewielki zestaw harmonicznych (np. dźwięk jednego klawisza pianina)
			\item Złożona - składają się z wielu częstotliwości o różnym natężeniu (np. głos ludzki).
		\end{itemize}
		\item Cyfrowa - informacja z postaci impulsów elektrycznych (wartości binarnych), dyskretna.
	\end{itemize}
	\textbf{Sygnał}:
	\begin{itemize}
		\item Analogowy - jest ciągły w czasie. Jest to sinusoidalna fala o określonej częstotliwości amplitudzie i fazie. Musi być dodatkowo wzmacniany przy przesyle na większą odległość.
		\item Cyfrowy - zapisany jako zakodowane skwantyzowane wartości w pewnych odstępach czasu. Transmisje sygnału cyfrowego cechują się większym stopniem niezawodności niż analogowe zwłaszcza na dłuższych dystansach. Jeżeli nastąpi potrzeba wzmocnienia, sygnał jest regenerowany cyfrowo, co nie zwiększa mocy szumu ani zniekształceń.
	\end{itemize}


	\section{Zdefiniować pojęcie widma sygnału oraz omówić numeryczne metody jego obliczania.}
	Widmo sygnału – przedstawienie sygnału w dziedzinie częstotliwości lub pulsacji. Do numerycznych metod obliczania należą:
	\begin{itemize}
		\item \textbf{Dyskretna transformata Fouriera} - ustala wzajemny związek między czasowej i częstotliwościowej reprezentacje sygnału przy jego  rozkładzie na szereg składowych harmonicznych. W rzeczywistych warunkach nie jest możliwa realizacja nieskończonego sumowania, gdyż nigdy nie osiągnęlibyśmy wyniku końcowego.
Wynika stąd, że liczba częstotliwości biorących udział w obliczeniach jest ograniczona.
		\item \textbf{Szybka transformacja Fouriera} – $O(N\log _{2}N)$ - algorytm wyznaczania dyskretnej transformaty Fouriera oraz transformaty do niej odwrotnej. Oblicza widmo na podstawie spróbkowanego sygnału. Wartości zwracane to liczby zespolone, (po normalizacji) moduł przedstawia amplitudę danej częstotliwości, argument określa fazę danej częstotliwości.
	\end{itemize}

	\section{Omówić skalę decybelową.}
	Skala decybelowa opisuje relację między 2 dowolnymi wielkościami, np. natężeniem mierzonego dźwięku i poziomem odniesienia.
	
	$$L_{dB} = 10 \cdot log_{10}\left( \frac{P_1}{P_2} \right) $$

	\section{Co to jest szerokość pasma oraz przepływności kanału transmisyjnego.}
	\textbf{Szerokość pasma} - różnica między górną a dolną częstotliwością pasma, które kanał jest zdolny przenieść z nierównomiernością nie gorszą niż 3dB.\\
	\textbf{Przepływność kanału} - zdolność kanału do przenoszenia informacji (ilość przesłanych bitów na sekundę). Do obliczania przepływności stosuje się wzór $P = 2B \cdot log_{2}M$, gdzie B to szerokość pasma, M to liczba dyskretnych poziomów (jezeli M = 2, każdy sygnał zawiera bit). Maksymalna teoretyczna przepływność kanału jest ograniczona prawem Shannona $P = B \cdot log_{2}\left( 1+ \frac{S}{N} \right)$, gdzie $\frac{S}{N}$ to stosunek mocy sygnału do szumu.

	\section{Omówić zagadnienie modulacji, ze szczególnym uwzględnieniem modulacji cyfrowych}
	Modulacja to proces zmiany cech pewnego sygnału (zwanego sygnałem nośnym) innym sygnałem (zwanym sygnałem modulującym) w celu zawarcia informacji w sygnale nośnym.
	
	Do modulacji cyfrowych należą: 
	\begin{itemize}
		\item ASK (amplituda fali nośnej jest modulowana kwadratowym sygnałem modulującym)
		\item PSK (to samo dla fazy)
		\item FSK (to samo dla częstotliwości)
		\item QAM (kodowanie amplitudą i fazą w celu zawarcia większej ilości informacji, często prezentowane przez diagramy konstelacyjne)
	\end{itemize}

	Do mediów transmisyjnych należą:
	\begin{itemize}
		\item przewodowe
		\begin{itemize}
			\item kable symetryczne (skrętka)
			\item kable niesymetryczne
			\item kable współosiowe (kabel koncentryczny)
			\item kable światłowodowe
			\item kable energetyczne
		\end{itemize}
		\item bezprzewodowe
		\begin{itemize}
			\item fale radiowe
			\item fale świetlne
		\end{itemize}
	\end{itemize}

	\section{Wymienić znane media transmisyjne.}
	\begin{itemize}
		\item przewodowe:
		\begin{itemize}
			\item kable symetryczne - składają się z dwóch przewodów, w których płyną prądy o takim samym natężeniu, ale w przeciwnych kierunkach,
			\item kable niesymetryczne - prąd płynie przez przewód sygnałowy. Drugi przewód jest uziemieniem,
			\item kable koncentryczne - składa się z dwóch koncentrycznych przewodów co zapewnia większą odporność na zakłócenia – tym samym wyższą jakość transmisji,
			\item kable światłowodowe - przezroczysta zamknięta struktura z włókna szklanego wykorzystywana do propagacji światła jako nośnika informacji
		\end{itemize}
		\item bezprzewodowe:
		\begin{itemize}
			\item fale z zakresu podczerwieni,
			\item fale radiowe,
		\end{itemize}
	\end{itemize}

	\section{Omówić problem uwierzytelniania na przykładach: uwierzytelniania SYK, uwierzytelniania SYH, uwierzytelniania SYA oraz pojęcia hasła, karty magnetycznej, karta elektronicznej, karty identyfikacyjnej SIM oraz omówić techniki biometryczne.}
	Metody uwierzytelniania:
	\begin{itemize}
		\item \textbf{SYK} (\textit{something you know}) - na podstawie tego, co użytkownik zna (np. hasło),
		\item \textbf{SYH} (\textit{something you have}) - na podstawie tego, co użytkownik ma (np. token, karta),
		\item \textbf{SYA} (\textit{something you are}) - na podstawie tego, kim użytkownik jest (np. odcisk palca).
	\end{itemize}

	\begin{description}
		\item[Hasło] - ciąg znaków.
		\item[Karta magnetyczna] - karta z paskiem magnetycznym, na podstawie którego przebiega autoryzacja.
		\item[Karta elektroniczna] - bezpieczniejsza niż magnetyczna, zawiera układ elektroniczny, który pozwala na lepszą autoryzację.
		\item[Karta identyfikacyjna SIM] - karty z możliwością zapisu haseł dostępu, adresacji numerów, algorytmów szyfrowania, książki telefonicznej, pamięci komunikatów SMS, wielu stopni uprawnień.
	\end{description}

Techniki biometryczne:
	\begin{itemize}
		\item rozpoznawanie odcisku palca
		\item skanowanie siatkówki oka
		\item rozpoznawanie cech twarzy
		\item rozpoznawanie geometrii ręki/palca
		\item rozpoznawanie głosu
		\item rozpoznawanie podpisu
	\end{itemize}

	\section{Formaty danych liczbowych.}
	\begin{itemize}
		\item Liczby całkowite bez znaku/ze znakiem (kod U2), 
		\item liczby stałoprzecinkowe - zakłada określenie ile bitów tworzy część całkowitą liczby, a ile część ułamkową. 
		\item liczby zmiennoprzecinkowe - zapisujemy w pamięci przy pomocy trzech składowych: znaku, wykładnika, mantysy
	\end{itemize}

	\section{Omówić zasady wykonania operacji arytmetycznych w kodzie U2.}
	\begin{itemize}
		\item Dodawanie i odejmowanie -- bezpośrednio, bitowe
		\item Mnożenie -- liczby są rozszerzane do do dwukrotnie większej reprezentacji (nie zawsze konieczne), następnie przeprowadzone jest bitowe mnożenie
		\item Dzielenie -- liczby są zamieniane na reprezentację bezznakową, po podzieleniu następuje przywrócenie znaku
\end{itemize}		

	\section{Omówić zasady wykonania operacji na liczbach zmiennopozycyjnych.}
	Według standardu IEEE, dodawanie, odejmowanie, mnożenie i dzielenie wykonywane jest dokładnie a następnie jest zaokrąglane do najbliższej lub parzystej cyfry - w praktyce jest to nieefektywne; ten sam efekt można uzyskać wykorzystując dodatkowe bity kontrolne (guard, round, sticky). Po zaokrągleniu wynik jest normalizowany. Przy dodawaniu i odejmowaniu, liczby sprowadzane są do tego samego wykładnika. Przy mnożeniu/dzieleniu wykładnik jest dodawany/odejmowany. Operacja jest dalej przeprowadzana na wartościach mantysy. Operacje dodawania i mnożenia są przemienne ale nie koniecznie łączne ani rozdzielne,\\tj. a + b = b + a ale a + (b + c) != (a + b) + c, i a * (b + c) != a * b + a * c (równość tylko w pewnych przypadkach).

	\section{Różnice między pamięcią statyczną i dynamiczną.}
	p. \ref{sec:statdyn}

	\section{Wymienić standardowe postacie wyrażeń boolowskich.}
	\begin{itemize}
		\item \textbf{DNF} (disjunctive normal form) -- suma iloczynów logicznych,
		\item \textbf{FDNF} (full DNF) -- suma iloczynów logicznych, gdzie w każdej sumie znajduje się każda zmienna dokładnie raz,
		\item \textbf{CNF} (conjunctive normal form) -- iloczyn sum logicznych,
		\item \textbf{FCNF} -- analogicznie do FDNF. Jedyne operacje dozwolone w tych postaciach to AND, OR i NOT.
	\end{itemize}

	\section{Omówić kombinacyjne i sekwencyjne układy logiczne.}
	Kombinacyjne układy logiczne - rodzaj układów cyfrowych charakteryzujący się tym, że stan wyjść zależy wyłącznie od stanu wejść.

	Sekwencyjne układy logiczne - rodzaj układów cyfrowych charakteryzujący się tym, że stan wyjść zależy od stanu wejść układu oraz od poprzedniego stanu, zwanego stanem wewnętrznym, pamiętanego w zespole rejestrów (pamięci).

	\section{Scharakteryzować poszczególne etapy procesu konwersji analogowo-cyfrowej.}
	\begin{enumerate}
		\item Filtrowanie (szumów itp.),
		\item Próbkowanie (pobieranie wartości co pewien okres czasu),
		\item Kwantyzacja (zaokrąglanie wartości do skończonych reprezentacji),
		\item Kodowanie (zamiana sygnału w kod zrozumiały dla urządzenia).
	\end{enumerate}

	\section{Omówić ogólną charakterystykę filtrów w cyfrowych.}
	Filtr cyfrowy to system, który przeprowadza operacje na spróbkowanym sygnale prowadzące do redukcji lub uwydatnienia pewnych elementów tego sygnału. Filtrowanie może przebiegać w dziedzinie czasu lub częstotliwości. W dziedzinie częstotliwości właściwości filtru opisuje transmitancja.

	Algorytm realizowany przez program komputerowy lub cyfrowy układ sekwencyjny, który w reakcji na ciąg próbek sygnału dyskretnego podanego na wejście odpowiada ciągiem próbek wyjściowych, zgodnie z deterministyczną funkcją przejścia, która może być liniowa lub nieliniowa.

	\section{Opisać proces akwizycji i kodowania danych multimedialnych w kontekście zastosowania ich w systemach transmisji strumieniowej.}
	\textbf{Akwizycja danych} – w informatyce i analizie sygnałów pierwszy etap przetwarzania danych polegający na ich przygotowaniu do dalszej obróbki czy interpretacji; obejmuje on m.in. przechwytywanie, próbkowanie, czy kwantowanie danych w dowolnej postaci, często różnorakich sygnałów, np. w postaci falowej.\\
	Dane multimedialne maja zazwyczaj duży rozmiar. W aplikacji multimedialnej dane te sa kompresowane, transmitowane i prezentowane użytkownikowi. Akwizycja i kodowanie (w tym kompresja) sa potrzebne do efektywnej transmisji strumieniowej.

	\section{Wymienić i omówić podstawowe parametry stosowane przy definiowaniu jakości usług.}
	\begin{itemize}
		\item utrata pakietów
		\item fluktuacja opóźnień
		\item opóźnienie
		\item zmiana kolejności pakietów
		\item BER (Bit Error Rate)
	\end{itemize}

	\section{Wymienić i omówić podstawowe metody szeregowania pakietów.}
	\begin{itemize}
		\item kolejki FIFO: w przypadku przeciążenia, nowe pakiety mogą zostać odrzucone,
		\item kolejki priorytetowe: jest kilka (4?) kolejek o różnych priorytetach, kolejki opróżniane są w kolejności od najwyższego priorytetu,
		\item kolejki cykliczne i ważone WFQ: zapewnia sprawiedliwy przydział łącza wszystkim rodzajom ruchu, stosowany w przypadkach, gdy w sieci znajdują się źródła o dużym zróżnicowaniu natężeń,
		\item kolejkowanie custom queuing: gwarantuje, że żaden typ ruchu nie przekroczy skonfigurowanego procenta przydzielonej mu przepustowości,
		\item round-robin: każdy użytkownik obsługiwany jest cyklicznie.
	\end{itemize}

	\section{Różnica między standardami JPEG i JPEG2000, rodzaje transformacji obrazu wykorzystywane w kodowaniu obrazów.}
	JPEG
	\begin{itemize}
		\item dyskretna transformata kosinusowa
		\item kompresja stratna
	\end{itemize}
	
	JPEG2000
	\begin{itemize}
		\item dyskretna transformata falkowa
		\item kompresja stratna oraz bezstratna w tym samym strumieniu pliku
		\item nowszy standard
		\item lepsza jakość obrazu
		\item wyższy współczynnik kompresji dla kompresji stratnej
	\end{itemize}

	Rodzaje transformacji:
	\begin{itemize}
		\item dyskretna transformacja kosinusowa - kompromis pomiędzy uzyskiwanym stopniem kompresji a złożonością obliczeniową
		\item dyskretna transformacja falkowa - bardzo wysoki stopień kompresji, stosowana m.in. w standardach MPEG 2000, JPEG 2000
		\item dyskretna transformacja Fouriera,
		\item transformacja Hougha.
	\end{itemize}

	\section{Scharakteryzować kod Graya jako przykład elementu wchodzącego w skład metod cyfrowej modulacji sygnału.}
	Kod Graya charakteryzuje się tym, że dwa kolejne słowa kodowe różnią się jednym bitem. Stosowane są w korekcji błędów. Np. w modulacji cyfrowej QAM, gdzie dane są transmitowane w 4-bitowych symbolach, diagram konstelacji sygnału jest tak stworzony, aby kombinacje bitów w przylegających symbolach na konstelacji różniły się tylko jednym bitem. Po połączeniu tego z , która może korygować jednobitowe błędy, odbiornik może korygować błędy , które sprawiają, że punkty konstelacji odchylają się w stronę przyległych punktów. Dzięki temu system transmisji jest mniej podatny na zakłócenia.

	\section{Różnica między kodami detekcyjnymi i korekcyjnymi - przykłady zastosowań.}
	\begin{description}
		\item[Kody detekcyjne.] Kody wykrawające błędy w odebranych danych. Najczęściej używane są sumy kontrolne wyliczone z transmitowanej wiadomości. Błąd może być pojedynczy lub seryjny - dotyczący grupy kolejnych bitów. Ochrona transmisji przed błędami polega na odpowiednim kodowaniu przesyłanej informacji
		\begin{itemize}
			\item dwukrotne przesyłanie danych - kosztowne, przepustowość kanału spada dwukrotnie
			\item bit parzystości - do przesyłanego słówka dodajemy jeden bit o takim stanie, aby liczba wszystkich bitów o stanie 1 w tak powiększonym słowie informacyjnym była parzysta (czyli podzielna przez 2)
		\end{itemize}
		\item[Kody korekcyjne.] Technika dodawania nadmiarowości do transmitowanych cyfrowo informacji. Umożliwia całkowitą lub częściową detekcję i korekcję błędów powstałych w wyniku zakłóceń. Dzięki temu nie ma potrzeby wykorzystywania kanału zwrotnego, do poinformowania nadawcy o błędzie i konieczności ponownego przesłania informacji. Kodowanie korekcyjne jest więc wykorzystywane wtedy, gdy retransmisja jest kosztowna, kłopotliwa lub niemożliwa, np. ze względu na ograniczenia czasowe.
		\begin{itemize}
			\item potrójne przesyłanie danych - wysoce kosztowne, przepustowość kanału spada trzykrotnie
			\item kod Hamminga - pozwala naprawić pojedyncze przekłamania bitów w odebranym słowie binarnym. 
		\end{itemize}
	\end{description}

\end{document}